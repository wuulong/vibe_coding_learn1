ID,主類別,次類別,任務,範例提示 (Prompt),關鍵要素與原理
2.3-1,第 2 節：核心互動技巧：精準提示工程,2.3 模式驅動開發：以設計模式作為提示的鷹架,使用工廠模式實作資料匯出器,"請使用 Python 實作一個**工廠模式 (Factory Pattern)**.\n\n1. **意圖**：根據指定的格式字串 (`\'json\'`, `\'csv\'`, `\'xml\'`)，建立對應的資料匯出器物件 (Data Exporter)。\n2. **角色定義**：\n    - **Product (產品)** 介面叫做 `Exporter`，它必須定義一個 `export(data: dict) -> str` 的抽象方法。\n    - **ConcreteProduct (具體產品)** 包括 `JsonExporter`、`CsvExporter` 和 `XmlExporter`。\n    - **Creator (創建者)** 是一個名為 `ExporterFactory` 的類別，它有一個靜態方法 `get_exporter(format: str) -> Exporter`。\n3. **約束**：如果傳入未知的格式，工廠方法應拋出 `ValueError`。",**模式驅動** (`工廠模式`)：明確指定設計模式，利用 AI 對模式的深度理解生成結構優良的程式碼。**角色定義** (`Product`, `ConcreteProduct`, `Creator`)：清晰定義模式中的各個角色及其對應的業務概念。**具體約束** (`ValueError`)：確保 AI 處理邊界情況和錯誤。
2.3-2,第 2 節：核心互動技巧：精準提示工程,2.3 模式驅動開發：以設計模式作為提示的鷹架,使用策略模式設計折扣計算模組,"我需要為一個電商結帳系統設計折扣模組。請使用 Python 的**策略模式 (Strategy Pattern)** 來實作。\n\n1. **Context (上下文)** 角色是一個名為 `ShoppingCart` 的類別。它有一個 `items` 列表（每個 item 是一個有 `price` 屬性的物件）和一個 `set_discount_strategy` 方法。它最重要的方法是 `calculate_final_price()`。\n2. **Strategy (策略)** 介面是 `DiscountStrategy`，它需要一個 `calculate(total_price: float) -> float` 的抽象方法。\n3. **ConcreteStrategy (具體策略)** 至少實作三個：\n    - `NoDiscountStrategy`: 回傳原價。\n    - `PercentageDiscountStrategy(percentage)`: 計算百分比折扣。\n    - `FixedDiscountStrategy(amount)`: 折抵一個固定金額。\n\n請提供完整的程式碼與使用範例。",**模式驅動** (`策略模式`)：將演算法從主體中分離，提高系統彈性與擴展性。**角色定義** (`Context`, `Strategy`, `ConcreteStrategy`)：明確定義模式中的各個角色及其職責。**完整範例**：要求提供完整的程式碼與使用範例，確保可直接應用。
2.4-1,第 2 節：核心互動技巧：精準提示工程,2.4 測試驅動提示：用測試案例定義需求,使用測試驅動提示實作版本號解析函式,"我正在實作一個版本號解析器。這裡有一組為它編寫的 `pytest` 測試案例。\n\n請你提供一個名為 `version_parser.py` 的 Python 檔案，裡面包含一個 `parse_version_string` 函式。這個函式的實作必須能夠**完全通過**以下所有的測試。\n\nPython\n\n```\n# test_version_parser.py\nimport pytest\nfrom version_parser import parse_version_string # 假設目標檔案與函式名\n\ndef test_full_version():\n    """測試完整的 major.minor.patch 格式"""\n    assert parse_version_string("1.2.3") == (1, 2, 3)\n\ndef test_with_v_prefix():\n    """測試帶有 \'v\' 前綴的格式"""\n    assert parse_version_string("v2.10.1") == (2, 10, 1)\n\ndef test_minor_version_only():\n    """測試只有 major.minor 的格式，patch 應為 0"""\n    assert parse_version_string("3.5") == (3, 5, 0)\n\ndef test_major_version_only():\n    """測試只有 major 的格式，minor 和 patch 應為 0"""\n    assert parse_version_string("4") == (4, 0, 0)\n    assert parse_version_string("v5") == (5, 0, 0)\n\ndef test_invalid_format():\n    """測試無效輸入，應拋出 ValueError"""\n    with pytest.raises(ValueError):\n        parse_version_string("1.a.3")\n    with pytest.raises(ValueError):\n        parse_version_string("invalid")\n    with pytest.raises(ValueError):\n        parse_version_string("1.2.3.4")\n```\n\n請確保你的實作足夠健壯，能夠處理所有測試中涵蓋的情況。",**測試驅動提示** (`pytest` 測試案例)：將需求轉化為精確的、可執行的測試案例，消除歧義。**可驗證的正確性**：程式碼必須通過所有測試，抵抗 LLM 幻覺。**邊界條件**：透過測試案例迫使 AI 考慮各種邊界情況。
3.1-1,第 3 節：工具鏈整合與工作流革新,3.1 精通 GitHub Copilot：從自動完成到智能副駕,使用註解引導 Copilot 生成函式,"Python\n\n```\n# 函式名稱: download_file_with_retry\n# 功能描述: 從指定的 URL 下載檔案到本地路徑，並實作指數退避的重試機制。\n# 參數:\n#   url (str): 要下載的檔案 URL。\n#   local_path (str): 儲存檔案的本地路徑。\n#   max_retries (int): 最大重試次數，預設為 3。\n# 回傳值:\n#   bool: 成功時回傳 True，在所有重試失敗後回傳 False。\n# 可能引發的錯誤:\n#   ValueError: 當 URL 格式無效時。\n#\n```\n\n當您寫完這段註解並換行後，Copilot 幾乎能一字不差地生成一個結構完整、包含錯誤處理與重試邏輯的高品質函式，因為您已經為它提供了完整的規格說明書。",**註解藍圖**：透過詳細的註解提供函式規格，精準引導 AI 生成程式碼。**高品質產出**：AI 能生成結構完整、包含錯誤處理的函式。
3.1-2,第 3 節：工具鏈整合與工作流革新,3.1 精通 GitHub Copilot：從自動完成到智能副駕,使用函式簽名和 Docstring 引導 Copilot 生成程式碼,"Python\n\n```\nimport pandas as pd\n\ndef clean_sales_data(df: pd.DataFrame, columns_to_drop: list[str] = None) -> pd.DataFrame:\n    """\n    清理並預處理銷售數據 DataFrame。\n\n    此函式會執行以下操作：\n    1. 複製一份原始 DataFrame 以避免修改原物件。\n    2. 如果提供了 columns_to_drop，則刪除指定欄位。\n    3. 將 \'order_date\' 欄位轉換為 datetime 物件。\n    4. 填充 \'unit_price\' 和 \'quantity\' 欄位的缺失值為 0。\n    5. 移除 \'customer_id\' 為空的資料列。\n\n    Args:\n        df (pd.DataFrame): 包含銷售數據的原始 DataFrame。\n        columns_to_drop (list[str], optional): 需要被移除的欄位列表. Defaults to None.\n\n    Returns:\n        pd.DataFrame: 清理完成後的 DataFrame。\n    """\n    # 將游標停在這裡，Copilot 將會根據您的 Docstring 逐一完成上述步驟\n    \n```\n\nCopilot 會閱讀您的 Docstring，將其視為一個步驟清單，並生成符合描述的程式碼。",**函式簽名與 Docstring**：提供清晰的函式定義和詳細的說明，引導 AI 逐步完成實作。**Pythonic 引導**：利用 Python 慣例提升生成程式碼的品質和可讀性。
3.1-3,第 3 節：工具鏈整合與工作流革新,3.1 精通 GitHub Copilot：從自動完成到智能副駕,使用範例引導 Copilot 學習程式碼模式,"Python\n\n```\n# 定義 API 回應的錯誤碼與訊息\nERROR_CODES = {\n    1001: "Invalid API Key",\n    1002: "User not found",\n    1003: "Permission denied",\n    # 將游標停在這裡，Copilot 會自動建議 1004, 1005... \n    # 並且根據上下文猜測可能的錯誤訊息，例如 "Request timeout" 或 "Invalid parameter"。\n}\n```",**範例引導**：透過提供少量範例，讓 AI 學習並遵循程式碼模式，自動補全相似結構。**模式學習**：AI 能自動建議後續相似的內容。
3.1-4,第 3 節：工具鏈整合與工作流革新,3.1 精通 GitHub Copilot：從自動完成到智能副駕,使用 @workspace 理解 Django 專案使用者模型擴展,"`@workspace 我的 Django 專案中，使用者模型 (User Model) 是如何擴展的？請找出相關的 models.py 和 settings.py 中的設定。`",**全域上下文** (`@workspace`)：讓 AI 理解整個專案結構，進行專案級的分析。**專案架構理解**：快速找出相關設定和檔案，加速專案上手。
3.1-5,第 3 節：工具鏈整合與工作流革新,3.1 精通 GitHub Copilot：從自動完成到智能副駕,使用 @workspace 生成符合專案風格的驗證函式,"`@workspace 根據我現有的`utils/validators.py`檔案風格，幫我寫一個新的函式，用來驗證台灣的手機號碼格式。`",**風格一致性**：AI 根據現有檔案風格生成新程式碼，確保專案風格統一。**專案上下文**：利用專案內部的程式碼作為參考，生成更符合需求的內容。
3.1-6,第 3 節：工具鏈整合與工作流革新,3.1 精通 GitHub Copilot：從自動完成到智能副駕,使用 @workspace 進行 Flask 專案快取機制開發規劃,"`@workspace 我想為這個 Flask 專案加入一個基於 Redis 的快取機制，我應該在哪幾個檔案中進行修改？請提供一個初步的實作步驟。`",**開發規劃**：AI 提供初步實作步驟和修改檔案建議，輔助高層次開發規劃。**系統性思考**：幫助開發者從整體角度考慮變更影響。
3.1-7,第 3 節：工具鏈整合與工作流革新,3.1 精通 GitHub Copilot：從自動完成到智能副駕,解釋複雜的正規表示式函式,"(選取一段充滿正規表示式的函式後)\n\n請用中文詳細解釋這段程式碼的功能，特別是每一部分正規表示式的含義。",**程式碼理解**：AI 詳細解釋複雜程式碼，包括正規表示式，加速理解。**上下文提問**：直接選取程式碼提問，獲得精準解釋。
3.1-8,第 3 節：工具鏈整合與工作流革新,3.1 精通 GitHub Copilot：從自動完成到智能副駕,重構冗長函式以分離資料庫查詢,"(選取一個冗長的函式後)\n\n請將這段程式碼重構。將資料庫查詢的部分獨立成一個函式，並將硬編碼的 SQL 查詢參數化以防止 SQL Injection。",**智能重構**：AI 根據指令重構程式碼，提升可讀性、可維護性和安全性。**安全考量**：自動考慮 SQL Injection 等安全問題。
3.1-9,第 3 節：工具鏈整合與工作流革新,3.1 精通 GitHub Copilot：從自動完成到智能副駕,根據 Traceback 輔助除錯 ZeroDivisionError,"(將終端機中的 Python Traceback 錯誤訊息貼入聊天視窗)\n\n我執行程式時遇到了這個錯誤：[貼上 Traceback]。錯誤訊息顯示問題出在ZeroDivisionError，請根據我目前開啟的analytics/report.py檔案，找出可能造成這個錯誤的程式碼位置並提供修正建議。",**輔助除錯**：AI 分析錯誤訊息和程式碼，找出錯誤位置並提供修正建議。**高效排查**：縮短故障排除時間。
3.1-10,第 3 節：工具鏈整合與工作流革新,3.1 精通 GitHub Copilot：從自動完成到智能副駕,使用 /fix 修正排序演算法邏輯錯誤,"/fix 請修正這個排序演算法中的邏輯錯誤，它在處理包含重複元素的列表時會出錯。",**自動修正** (`/fix`)：AI 直接提供修正後的程式碼，簡化錯誤修復流程。**精準定位**：針對特定邏輯錯誤進行修正。
3.1-11,第 3 節：工具鏈整合與工作流革新,3.1 精通 GitHub Copilot：從自動完成到智能副駕,使用 /tests 為函式生成單元測試,"/tests 請為這個函式產生一組使用 pytest 框架的單元測試，需要包含正常情況、邊界條件和無效輸入的測試案例。",**自動生成測試** (`/tests`)：AI 為函式生成全面的單元測試，提升測試覆蓋率。**效率提升**：節省編寫測試 boilerplate 的時間。
3.2-1,第 3 節：工具鏈整合與工作流革新,3.2 整合式 AI 助理的威力 (Gemini Code Assist / Jules),使用內部驗證模組擴充 Flask API 端點,"`我需要擴充我們的 \'order-management-service\\'。請**參考 \'common/auth_utils.py\' 中現有的`require_auth`裝飾器**，為我產生一個新的 API 端點`/orders/{order_id}/cancel`的 Flask 路由函式框架。`",**企業級程式碼庫接地**：AI 根據公司內部程式碼庫生成符合規範的程式碼。**風格一致性**：確保使用組織內的標準工具和實踐。
3.2-2,第 3 節：工具鏈整合與工作流革新,3.2 整合式 AI 助理的威力 (Gemini Code Assist / Jules),撰寫 Google Cloud Function 產生 GCS 簽名 URL,"`請幫我寫一個 Python 3.12 的 Google Cloud Function。\n\n1. 觸發條件是檔案上傳到名為 \'user-uploads-bucket\' 的 GCS 儲存桶。\n2. 函式的功能是為這個新上傳的檔案，產生一個有效期限為 1 小時的簽名 URL (v4 signing process)。\n3. 最後將這個 URL 記錄到 Cloud Logging 中。 請使用 \'google-cloud-storage\' 函式庫。`",**生態系無縫整合**：AI 精通 GCP 服務，生成高度相關的雲端原生程式碼。**自動化雲端操作**：簡化雲端資源操作和配置。
3.2-3,第 3 節：工具鏈整合與工作流革新,3.2 整合式 AI 助理的威力 (Gemini Code Assist / Jules),生成 Google Cloud SQL Terraform 設定檔,"`我需要一個 Terraform 設定檔，用來建立一個 Google Cloud SQL for PostgreSQL 的執行個體，規格為 db-n1-standard-2，並開啟每日自動備份。`",**IaC 生成**：AI 生成雲端基礎設施程式碼，加速基礎設施部署。**精確配置**：根據詳細規格生成精確的設定檔。
3.2-4,第 3 節：工具鏈整合與工作流革新,3.2 整合式 AI 助理的威力 (Gemini Code Assist / Jules),檢查 GCS 儲存桶 Terraform 設定檔的安全性,"(選取一段建立 GCS 儲存桶的 Terraform 程式碼後) 請檢查這段 HCL 程式碼，確保它沒有將儲存桶設定為公開存取，並且開啟了版本控制功能。",**安全審查**：AI 分析 IaC 設定檔，找出潛在安全風險和不符合政策的地方。**自動化安全檢查**：提升基礎設施的安全性。
3.2-5,第 3 節：工具鏈整合與工作流革新,3.2 整合式 AI 助理的威力 (Gemini Code Assist / Jules),分析 Cloud Run 記憶體不足錯誤並提供建議,"`我的 Cloud Run 服務日誌中出現了大量的記憶體不足 (OOM) 錯誤。請分析可能的原因，並提供調整服務設定或優化程式碼的建議。`",**營運輔助**：AI 分析日誌並提供故障排除建議，縮短問題解決時間。**智能排查**：結合日誌和服務特性提供優化方案。
3.3-1,第 3 節：工具鏈整合與工作流革新,3.3 Google Jules (Gemini Code Assist) 實戰技巧,使用 @workspace 快速理解 Flask 專案初始化結構,"`@workspace 這個 Flask 專案的應用程式是如何被初始化的？請為我找出：\n\n1. 主要的應用程式工廠 (app factory) 函式在哪個檔案中。\n2. 專案的設定檔 (config) 是如何被載入的。\n3. 整個專案中，所有被註冊的藍圖 (Blueprints) 及其對應的 URL 前綴。`",**專案級深度問答**：AI 快速分析整個專案，提供宏觀架構視圖。**加速上手**：幫助開發者快速理解陌生專案的結構。
3.3-2,第 3 節：工具鏈整合與工作流革新,3.3 Google Jules (Gemini Code Assist) 實戰技巧,使用 @workspace 評估修改 Pydantic 模型對專案的影響,"`@workspace 我計畫修改`src/models/user_models.py`檔案中的`UserModel`Pydantic 模型，為其新增一個`last_login_at: datetime | None`的選用欄位。請全面掃描整個工作區，找出所有直接或間接使用到`UserModel`的地方，並條列出這次修改可能會造成潛在影響的檔案與函式。`",**影響力分析**：AI 執行全域依賴關係查找，評估變更風險。**風險管理**：在變更前全面掌握潛在影響，降低開發風險。
3.3-3,第 3 節：工具鏈整合與工作流革新,3.3 Google Jules (Gemini Code Assist) 實戰技巧,使用智能操作為函式生成單元測試,"在您的程式碼檔案中，完成或用滑鼠選取一個您想要測試的函式（例如：`def calculate_shipping_fee(...)`）。點擊該函式旁出現的「燈泡」圖示，或直接右鍵，選擇「Gemini: 產生測試 (Generate Tests)」。AI 會自動分析該函式的簽名、邏輯與回傳值。它會在 `tests/` 目錄下，建立一個對應的測試檔案（例如 `test_your_file.py`），並在其中生成使用 `pytest` 框架的、覆蓋了正常路徑與邊界條件的測試案例。",**智能操作**：IDE 深度整合，一鍵生成測試。**降低門檻**：極大降低實踐 TDD 和提升測試覆蓋率的成本。
3.3-4,第 3 節：工具鏈整合與工作流革新,3.3 Google Jules (Gemini Code Assist) 實戰技巧,使用智能操作為函式補全 Docstring,"選取一段缺乏文件註解的函式。在右鍵選單中，選擇「Gemini: 新增說明文件 (Add Documentation)」。AI 將會生成一段符合標準格式（例如 Google 風格或 reStructuredText）的完整 Docstring，精確地描述函式的功能、參數 (`Args`)、回傳值 (`Returns`)，甚至能根據程式碼邏輯，自動識別出可能拋出的錯誤 (`Raises`)。",**自動文件化**：AI 自動生成專業級 Docstring，提升程式碼可讀性。**標準化**：推行團隊文件規範，節省時間。
3.3-5,第 3 節：工具鏈整合與工作流革新,3.3 Google Jules (Gemini Code Assist) 實戰技巧,生成 Google Cloud Build 和 Cloud Run IaC,"`@googlecloud 我需要為目前這個 Python 專案撰寫一個`cloudbuild.yaml` 檔案。請幫我設定一個包含三個步驟的建置流程：\n\n1. 執行 `poetry install` 安裝依賴。\n2. 使用 Kaniko 建置 Docker 映像。\n3. 將建置好的映像推送到 Artifact Registry。\n\n另外，請再幫我產生一個部署到 Cloud Run 的 `service.yaml` 設定檔。服務需要 2 個 vCPU 和 4GiB 記憶體，並且需要設定一個環境變數 `DATABASE_URL`，其值必須從 **Secret Manager** 中，安全地讀取名為 `prod-db-connection-string` 的最新版密鑰。`",**深度雲端整合**：AI 精通 GCP 生態系，生成複雜的 IaC 配置。**自動化部署**：簡化雲端原生應用部署流程。
3.3-6,第 3 節：工具鏈整合與工作流革新,3.3 Google Jules (Gemini Code Assist) 實戰技巧,在 IDE 內分析 Cloud Run 錯誤日誌並提供修正建議,"在 VS Code 的「Cloud Code」面板中，直接串流查看您的 Cloud Run 或 GKE 服務的即時日誌。當您看到一條可疑的錯誤日誌時，直接用滑鼠選取該行日誌。在 Gemini 聊天視窗中，AI 會自動將該日誌作為上下文，您可以直接提問：\n\n`@googlecloud 我的 Cloud Run 服務剛才吐出了這條`KeyError: \'user_profile\'`的錯誤日誌。請對照我目前開啟的`main.py`檔案第 85 行附近的程式碼，分析這個錯誤發生的根本原因是什麼？是不是因為某個外部 API 回應的 JSON 結構改變了？請提供修正建議。`",**雲端日誌分析**：AI 將線上錯誤與本地程式碼關聯，提供高效除錯。**快速故障排除**：縮短從問題發現到解決的時間。
3.4-1,第 3 節：工具鏈整合與工作流革新,3.4 超越 IDE：運用 Playground 環境進行複雜原型設計,在 Playground 設計物流貨物分配演算法,"您需要為一個物流系統設計一套貨物分配演算法。規則非常複雜：需要考慮倉庫距離、貨車載重、交通狀況的即時權重、以及貨物的優先級。這種高度邏輯性的「思想實驗」，很難在 IDE 中透過註解或單次提問完成。\n\n**Playground 中的工作流**：\n\n1. **設定規則**：以自然語言清晰地定義問題的背景和所有約束條件。\n2. **提供範例 (Few-Shot)**：給出幾個簡單的貨物清單和理想的分配結果，讓 AI 學習您的分配邏輯。\n3. **迭代式探索**：透過連續提問來處理邊界條件。「如果 A 貨車中途拋錨，備用方案是什麼？」「如果 B 貨物的優先級突然提升，該如何動態調整路線？」\n4. **生成偽代碼**：當您與 AI 在邏輯上達成共識後，下達指令：「很好，根據我們以上的討論，請為這個分配邏輯生成一份詳細的偽代碼。」\n5. **生成最終程式碼**：審查並修改偽代碼後，最後一步才是：「現在，請將這份偽代碼完整地實作成一個名為 `LogisticsAllocator` 的 Python 類別。」",**Playground 優勢**：適用於開放、模糊、複雜的邏輯設計。**迭代探索**：透過多輪對話和範例，逐步精煉演算法。**原型設計**：從偽代碼到最終程式碼的逐步實現。
3.4-2,第 3 節：工具鏈整合與工作流革新,3.4 超越 IDE：運用 Playground 環境進行複雜原型設計,在 Playground 轉換和正規化非結構化客戶資料,"您需要處理一批從舊系統導出的、格式混亂的客戶資料文字檔。您需要從中提取出結構化的姓名、電話、地址，並統一格式。\n\n**Playground 中的工作流**：\n\n1. **定義任務與提供範例**：\n    \n    > `我將提供一些格式混亂的客戶資料。你的任務是從中提取 "name", "phone", "address" 三個欄位，並以 JSON 格式輸出。電話號碼需要統一為 "09XX-XXX-XXX" 的格式。\n    > \n    > ---\n    > \n    > ## **輸入 1**: "用戶: 陳大文, TEL: 0912345678, 住址: 台北市信義路五段7號" **輸出 1**: {\"name\": \"陳大文\", \"phone\": \"0912-345-678\", \"address\": \"台北市信義路五段7號\"}\n    > \n    > ## **輸入 2**: "李四/電話(0928) 123-456，他住在新竹市大學路1001號" **輸出 2**: {\"name\": \"李四\", \"phone\": \"0928-123-456\", \"address\": \"新竹市大學路1001號\"}\n    > \n    > 現在，請處理以下這筆新資料：\n    > \n    > \"王五先生，聯絡方式 0955.888.777，地址在高雄市...\"`\n    \n2. **調整與最佳化**：AI 的初版回答可能不完美，您可以透過編輯範例或新增更多邊界條件（例如沒有電話號碼的情況）來「訓練」它，直到它能穩定地產出您想要的結果。\n    \n3. **生成處理函式**：\n    \n    > `表現得很好。現在請將這個解析邏輯，封裝成一個名為`parse_customer_record`的 Python 函式。函式應接收一個字串作為輸入，回傳一個字典。請盡可能使用正規表示式來提高解析的準確度。`",**非結構化資料處理**：利用 Playground 處理格式混亂的資料，提取和正規化信息。**範例驅動**：透過提供輸入/輸出範例，訓練 AI 歸納模式。**迭代優化**：透過編輯和新增範例，提升解析準確度。
3.4-3,第 3 節：工具鏈整合與工作流革新,3.4 超越 IDE：運用 Playground 環境進行複雜原型設計,在 Playground 進行技術寫作和創意發想,"身為架構師，您需要撰寫一份技術白皮書、一篇介紹新技術的部落格文章、或是給高層的專案規劃簡報。這類任務需要創造力、清晰的結構和精準的措辭。\n\n**Playground 中的工作流**：\n\n1. **設定角色與風格 (System Instruction)**：「你是一位資深的技術佈道師，擅長用生動的比喻和清晰的結構來解釋複雜的技術概念。」\n2. **腦力激盪 (高溫)**：「我準備寫一篇關於『從 monolith 到 microservices 的演進』的文章，請提供 5 個吸引人的標題，並為每個標題附上三點大綱。」\n3. **草擬段落**：「請幫我展開『康威定律 (Conway\'s Law) 如何影響我們的組織與架構』這個段落，約 300 字。」\n4. **潤飾與精煉 (低溫)**：「這段文字不錯，但請讓語氣更具權威性，並將『strangler fig pattern』這個術語用一個更貼近生活的比喻來解釋。」",**創意寫作**：利用 Playground 進行技術文章、簡報的創意發想和內容生成。**參數控制**：透過溫度和系統指令控制 AI 的創意度和風格。**迭代精煉**：逐步完善內容，提升寫作品質。
3.5-1,第 3 節：工具鏈整合與工作流革新,3.5 打造個人化 AI 知識庫：沉澱與複用高效互動模式,生成 Python Poetry 專案的多階段 Dockerfile,"「請為一個使用 Poetry 的 Python 專案撰寫一個多階段 Dockerfile。\n\n1. **第一階段 (builder)**：使用 `python:3.12-slim` 作為基礎鏡像。複製 `pyproject.toml` 和 `poetry.lock` 檔案，然後安裝 Poetry 並執行 `poetry install --no-root --no-dev` 來安裝依賴。\n2. **第二階段 (final)**：同樣使用 `python:3.12-slim`。建立一個非 root 的使用者 `appuser`。從 `builder` 階段複製虛擬環境 `/venv` 到最終鏡像中。最後，複製應用程式原始碼，並設定 `CMD` 來啟動應用。\n3. 請確保檔案權限的設定是安全的。」",**知識庫沉澱**：記錄高效提示模板，便於未來複用。**多階段 Dockerfile**：生成優化鏡像大小和安全性的 Dockerfile。**精確指令**：提供詳細步驟和約束，確保生成內容符合需求。
3.5-2,第 3 節：工具鏈整合與工作流革新,3.5 打造個人化 AI 知識庫：沉澱與複用高效互動模式,將巢狀 if-else 重構為策略模式,"提供了原始的、充滿 `if/elif/else` 的 `calculate_fee` 函式程式碼。下達核心提示：「請使用**策略模式 (Strategy Pattern)** 來重構這段程式碼，讓未來新增支付方式時，不需要修改現有程式碼。」AI 一次性產出了包含 `FeeStrategy` 抽象基礎類別 (ABC)、`CreditCardStrategy`、`PayPalStrategy` 等具體策略類別，以及一個 `FeeCalculator` 上下文類別的完整、高品質程式碼。",**模式驅動重構**：明確指定設計模式，提升程式碼品質和可擴展性。**高效互動模式**：記錄成功的對話流程，便於未來複用。**開閉原則**：重構後程式碼符合開閉原則，易於擴展。
4.1-1,第 4 節：高階應用：架構設計與程式碼現代化,4.1 加速創新：從概念到可執行原型 (POC),為文字分析工具 POC 生成 Pydantic 資料模型,"「我正在建構一個文字分析工具。請使用 Pydantic 為我建立兩個資料模型：\n\n1. 請求模型 `AnalysisRequest`，包含一個欄位 `text: str`。\n2. 回應模型 `AnalysisResponse`，包含三個欄位：`summary: str`、`keywords: list[str]`、`sentiment: str`。」",**POC 生成**：快速生成原型核心組件。**資料模型定義**：使用 Pydantic 定義請求和回應資料結構。**加速創新**：快速驗證技術可行性與業務價值。
4.1-2,第 4 節：高階應用：架構設計與程式碼現代化,4.1 加速創新：從概念到可執行原型 (POC),為文字分析工具 POC 生成 FastAPI API 路由,"「很好。現在請使用 FastAPI 建立一個 API 端點 `/analyze`，HTTP 方法為 POST。它接收一個 `AnalysisRequest` 物件作為請求主體，並回傳一個 `AnalysisResponse` 物件。請先把核心的分析邏輯用一個回傳假資料的 `placeholder` 函式代替。」",**API 層生成**：基於資料模型生成 API 介面。**快速原型**：使用 placeholder 快速搭建 API 骨架。**加速開發**：縮短 POC 開發週期。
4.1-3,第 4 節：高階應用：架構設計與程式碼現代化,4.1 加速創新：從概念到可執行原型 (POC),為文字分析工具 POC 實作 AI 摘要與分析邏輯,"「接下來，請實作真正的核心邏輯。寫一個非同步函式 `analyze_text_with_ai`，它接收一段文字字串。在這個函式內部，請使用 `google.generativeai` 函式庫來呼叫 Gemini 模型，並用一個提示詞 (prompt) 來指示模型同時完成三件事：1. 生成文章的摘要。2. 提取 5 個關鍵字。3. 判斷文章的情緒是『正面』、『負面』還是『中性』。最後，將這三項結果組合成一個 `AnalysisResponse` 物件並回傳。」",**業務邏輯實作**：實作 POC 核心功能，呼叫 AI 模型。**多任務處理**：指示 AI 同時完成摘要、關鍵字和情緒分析。**AI 整合**：利用 `google.generativeai` 函式庫與 Gemini 模型互動。
4.1-4,第 4 節：高階應用：架構設計與程式碼現代化,4.1 加速創新：從概念到可執行原型 (POC),為文字分析工具 POC 生成 Streamlit 前端介面,"「請為我寫一個簡單的 Python Streamlit 應用程式。這個程式需要：\n\n1. 一個標題，例如「AI 文章分析工具」。\n2. 一個 `st.text_area` 讓使用者可以貼上長篇文章。\n3. 一個「開始分析」的按鈕。\n4. 當使用者點擊按鈕時，使用 `requests` 函式庫向本地運行的 FastAPI 後端（`http://127.0.0.1:8000/analyze`）發送 POST 請求。\n5. 成功獲取回應後，將摘要、關鍵字列表和情緒分析結果優雅地顯示在頁面上。」",**前端介面生成**：生成簡單的 Streamlit UI。**快速互動**：提供文字輸入和結果展示。**前後端連線**：使用 `requests` 呼叫後端 API。
4.2-1,第 4 節：高階應用：架構設計與程式碼現代化,4.2 LLM 輔助系統設計：從高層次概念到 API 合約,設計診所線上預約系統並分析架構優劣,"「我需要設計一個診所的線上預約系統。核心需求包括：病患可以查看不同醫生的可預約時段、進行線上預約、以及取消預約。醫生需要能夠管理自己的班表與可預約時間。系統還需要在預約前一天自動發送提醒。我們的團隊規模不大，但希望未來系統能有好的擴展性。請為我分析一下，採用『微服務架構』和『模組化單體 (Modular Monolith) 架構』各自的優缺點。」",**需求釐清**：以自然語言描述高層次需求和約束。**腦力激盪**：AI 提出不同架構風格的優劣分析。**發散思考**：探索設計可能性空間。
4.2-2,第 4 節：高階應用：架構設計與程式碼現代化,4.2 LLM 輔助系統設計：從高層次概念到 API 合約,拆解診所線上預約系統模組並定義職責,"「分析得很好。考量到我們團隊初期的開發效率，我們先採用『模組化單體』架構，但內部模組邊界要清晰，以便未來拆分成微服務。請幫我拆解出這個系統需要的核心模組，並描述每個模組的職責。」",**組件拆解**：AI 根據選定架構拆解服務或模組。**職責定義**：明確每個模組的功能和職責。**單一職責原則**：確保模組符合 SRP，便於未來擴展。
4.2-3,第 4 節：高階應用：架構設計與程式碼現代化,4.2 LLM 輔助系統設計：從高層次概念到 API 合約,為診所線上預約系統生成預約時序圖,"「針對『病患成功預約一個時段』這個核心使用者故事，請使用 Mermaid.js 的 sequenceDiagram 語法，描述從前端應用到後端各個模組之間的互動流程。」",**時序圖生成**：AI 生成基於文本的時序圖，描述組件互動。**溝通效率**：提升文件品質和溝通效率。**Mermaid.js**：使用標準圖表語言，易於生成和版本控制。
4.2-4,第 4 節：高階應用：架構設計與程式碼現代化,4.2 LLM 輔助系統設計：從高層次概念到 API 合約,為診所線上預約系統生成預約 API OpenAPI 規格,"「非常好。現在，請根據剛剛的時序圖，為『預約模組』中處理預約的端點，產生一份 OpenAPI 3.0 的 YAML 規格。這個端點的路徑是 POST /appointments。請詳細定義其請求主體 (requestBody)、各種回應 (responses) 的結構，包括成功 (201) 與客戶端錯誤 (400) 的情況。同時，也請提供對應的 Python Pydantic 模型。」",**API 合約生成**：AI 生成 OpenAPI 規格和 Pydantic 模型。**精確規格**：將非正式流程轉化為機器可讀的 API 契約。**前後端協作**：促進團隊並行開發，縮短週期。
4.3-1,第 4 節：高階應用：架構設計與程式碼現代化,4.3 解構遺留系統：程式碼庫分析與現代化策略,為無註解的 Python 2 函式生成摘要和註解,"將整個函式或檔案的程式碼貼給 AI，並下達指令：「這是一個沒有文件的 Python 2 函式。請你：1. 用一段話總結這個函式的高層次功能。2. 為這段程式碼逐行或逐邏輯區塊，添加詳細的中文註解。」",**程式碼理解**：AI 快速理解並總結程式碼功能。**註解生成**：為無註解程式碼添加詳細註解。**加速理解**：將複雜程式碼轉化為可讀文件。
4.3-2,第 4 節：高階應用：架構設計與程式碼現代化,4.3 解構遺留系統：程式碼庫分析與現代化策略,分析專案依賴並推測運行環境,"「分析這個 `requirements.txt` (或 `pom.xml`, `package.json`) 檔案。請列出所有外部依賴，並根據程式碼內容，推測每個函式庫在這個專案中的主要用途。同時，請推測執行此專案可能需要的環境變數或設定檔。」",**依賴分析**：AI 列出外部依賴並推測用途。**環境推測**：推測運行專案所需的環境變數和設定檔。**快速啟動**：縮短專案啟動準備時間。
4.3-3,第 4 節：高階應用：架構設計與程式碼現代化,4.3 解構遺留系統：程式碼庫分析與現代化策略,從 Java Servlet 程式碼提煉保險費用計算邏輯,"「請分析這段 Java Servlet 程式碼。將其中處理『保險費用計算』的核心業務規則，從所有與 Web 框架和資料庫連接相關的樣板程式碼 (boilerplate) 中分離出來，並以偽代碼 (pseudocode) 的形式呈現。」",**業務邏輯提煉**：AI 從混雜程式碼中分離核心業務規則。**偽代碼呈現**：以清晰的偽代碼形式呈現邏輯。**重構基礎**：為後續重構或重寫提供基礎。
4.3-4,第 4 節：高階應用：架構設計與程式碼現代化,4.3 解構遺留系統：程式碼庫分析與現代化策略,分析程式碼並識別壞味道及重構建議,"「(貼上一段程式碼後) 請分析這段程式碼，是否存在任何常見的『程式碼壞味道』，例如『上帝物件 (God Object)』、『義大利麵式程式碼 (Spaghetti Code)』或過多的重複程式碼？如果有的話，請指出具體位置，並建議可以採用的重構方法（例如：提煉函式、類別分離等）。」",**程式碼壞味道識別**：AI 識別常見的程式碼壞味道。**重構建議**：提供具體重構方法。**提升品質**：快速定位架構腐化點，改善程式碼品質。
4.3-5,第 4 節：高階應用：架構設計與程式碼現代化,4.3 解構遺留系統：程式碼庫分析與現代化策略,為 Java EE 應用提供現代化遷移路徑建議,"「我們有一個使用 Struts 1 和 EJB 2.0 的舊 Java EE 應用。我們計畫將其現代化為一個基於 Spring Boot 3 和 JPA 的微服務。請為我們提供一份詳細的遷移步驟清單、需要注意的關鍵挑戰，以及推薦的工具。」",**遷移路徑建議**：AI 提供詳細的技術棧遷移步驟和挑戰。**現代化策略**：生成高品質的遷移計畫草稿。**風險規避**：避免遺漏關鍵環節，降低風險。
4.3-6,第 4 節：高階應用：架構設計與程式碼現代化,4.3 解構遺留系統：程式碼庫分析與現代化策略,將 COBOL 程式翻譯成 Python 3 函式,"「這是一段用於計算利息的 COBOL 程式。請將其邏輯完整地翻譯成一個等效的 Python 3 函式。請保留原始的變數名（轉換為蛇形命名法），並添加註解來解釋每個計算步驟。」",**程式語言翻譯**：AI 將舊語言程式碼翻譯成現代語言。**邏輯等效**：確保翻譯後的邏輯與原始程式碼一致。**加速遷移**：處理困難的語言轉換，加速現代化進程。
4.3-7,第 4 節：高階應用：架構設計與程式碼現代化,4.3 解構遺留系統：程式碼庫分析與現代化策略,為遺留系統複雜函式生成單元測試,"「(貼上一段準備重構的複雜函式後) 為了確保重構的安全性，請為這個函式生成一組全面的單元測試案例。請使用 `pytest` 框架，並盡可能多地覆蓋其所有的 `if/else` 分支和邊界條件。」",**測試安全網**：為無測試保護的遺留程式碼建立安全網。**全面覆蓋**：生成覆蓋所有分支和邊界條件的測試案例。**降低風險**：在修改程式碼後驗證功能，降低現代化風險。
4.3-8,第 4 節：高階應用：架構設計與程式碼現代化,4.3 解構遺留系統：程式碼庫分析與現代化策略,為遺留函式庫包裹 FastAPI API 介面,"「我已經理解了這段舊的函式庫的功能。現在，請為它包裹一層現代化的 API 介面。請使用 FastAPI 框架，建立一個 RESTful API 端點，接收 JSON 請求，內部呼叫這個舊函式，並將結果以 JSON 格式回傳。」",**API 包裹**：為遺留邏輯提供現代化 API 介面。**絞殺者模式**：實施逐步替換舊系統的策略。**逐步現代化**：讓新系統逐步、安全地取代舊系統功能。
4.4-1,第 4 節：高階應用：架構設計與程式碼現代化,4.4 自動化決策記錄：生成架構決策紀錄 (ADR),根據會議筆記生成快取方案技術選型 ADR,"「你是一位資深的技術文件撰寫者。請根據我以下的會議筆記，幫我生成一份標準格式的架構決策紀錄 (ADR)。\n\n請使用 Markdown 格式，並為 ADR 加上一個獨特的編號（例如 ADR-001）。文件需包含以下段落：\n\n- **標題**: 一個簡潔的標題\n- **狀態**: 已接受 (Accepted)\n- **背景 (Context)**: 描述我們面臨的問題或決策點。\n- **決策 (Decision)**: 清晰地說明我們最終選擇了什麼方案。\n- **後果 (Consequences)**: 條列出這個決策帶來的好處、壞處、以及我們接受的權衡取捨。\n\n---\n\n我的原始筆記:\n\n_開會討論快取層的方案。選項 A: 用 Google Cloud Memorystore (託管的 Redis)。好處是方便，不用自己管維運，Google 負責。壞處是比較貴，而且版本和配置的控制權比較少。選項 B: 自己在 GKE 上架 Redis 叢集。好處是省錢，完全控制。壞處是維運超麻煩，高可用、故障轉移、安全性都要自己搞。我們團隊 Dev 多，Ops 少。專案趕時間，Q3 一定要上線。最後決定：先用 Memorystore，快速上線最重要。我們接受初期成本可能高一點，也接受被廠商綁住。一年後再評估要不要自己架。_\n\n---」",**ADR 生成**：AI 自動生成標準格式的架構決策紀錄。**降低門檻**：極大降低記錄決策的成本。**知識傳承**：將隱性知識轉化為團隊顯性資產。
5.1-1,第 5 節：風險、原則與未來展望,5.1 「信任但驗證」原則：對抗程式碼幻覺與隱藏的缺陷,識別 AI 生成程式碼中的邏輯錯誤,"要求 AI 寫一個函式，找出列表中的第二大數字。AI 可能的產出：\n\nPython\n\n```\ndef find_second_largest(numbers: list[int]) -> int | None:\n    if len(numbers) < 2:\n        return None\n    unique_numbers = sorted(list(set(numbers)), reverse=True)\n    if len(unique_numbers) < 2:\n        return None\n    return unique_numbers[1]\n```\n\n缺陷分析：這段程式碼看起來很合理，它先用 `set` 去重，然後排序。對於 `[1, 5, 2, 8, 3]` 這樣的輸入，它能正確回傳 `5`。但一位資深工程師會立刻質疑：\n- **效能問題**：`set` 和 `sorted` 操作都需要 `O(N log N)` 或 `O(N)` 的時間複雜度。對於一個極大的列表，僅需一次遍歷 `O(N)` 即可解決，這個實作顯然不是最優的。\n- **需求誤解**：如果需求是「找出數值第二大的元素」而非「第二大的不重複元素」，那麼對於輸入 `[8, 8, 7]`，預期結果應為 `8`，而此函式會回傳 `7`。\n驗證策略：為您的核心演算法與邏輯撰寫嚴格的單元測試，務必包含邊界情況（空列表、單一元素列表、全相等元素列表）和效能考量。",**程式碼幻覺**：AI 生成語法正確但邏輯有缺陷的程式碼。**邏輯錯誤識別**：資深工程師需識別邊界條件和需求誤解。**驗證策略**：透過單元測試和效能考量進行驗證。
5.1-2,第 5 節：風險、原則與未來展望,5.1 「信任但驗證」原則：對抗程式碼幻覺與隱藏的缺陷,識別 AI 生成程式碼中的隱藏效能問題,"要求 AI 寫一個函式，檢查兩個列表是否有共同的元素。AI 可能的產出：\n\nPython\n\n```\ndef has_common_element(list1: list, list2: list) -> bool:\n    for item1 in list1:\n        for item2 in list2:\n            if item1 == item2:\n                return True\n    return False\n```\n\n缺陷分析：對於小列表，這段 `O(n*m)` 的雙重迴圈程式碼可以運作。但如果這兩個列表各有數萬個元素，這個操作將會導致災難性的效能問題。一位有經驗的工程師會立刻想到，將其中一個列表轉換為集合 (Set)，利用其 `O(1)` 的平均查找時間，將整體複雜度降至 `O(n+m)`。\n驗證策略：進行程式碼審查時，對迴圈和資料處理保持「演算法複雜度」的警覺。對於效能敏感的區段，使用 `cProfile` 等工具進行效能剖析。",**效能問題**：AI 生成的程式碼可能在演算法效率上是次等的。**複雜度警覺**：資深工程師需警覺迴圈和資料處理的演算法複雜度。**驗證策略**：透過程式碼審查和效能剖析進行驗證。
5.1-3,第 5 節：風險、原則與未來展望,5.1 「信任但驗證」原則：對抗程式碼幻覺與隱藏的缺陷,識別 AI 生成程式碼中的潛在安全漏洞,"要求 AI 寫一個 Flask 的 API，用於讀取並回傳伺服器上的圖片。AI 可能的產出：\n\nPython\n\n```\nfrom flask import Flask, request, send_from_directory\n\napp = Flask(__name__)\nIMAGE_DIR = "/var/www/images"\n\n@app.route("/images")\ndef get_image():\n    filename = request.args.get(\'filename\')\n    # 危險！直接將使用者輸入拼接到檔案路徑\n    return send_from_directory(IMAGE_DIR, filename) \n```\n\n缺陷分析：這段程式碼存在典型的**路徑遍歷 (Path Traversal)** 漏洞。如果使用者傳入的 `filename` 是 `../../etc/passwd`，伺服器的敏感檔案就可能被洩漏。AI 只完成了「讀取檔案」的任務，卻沒有考慮到「安全地讀取檔案」這個隱含的需求。\n驗證策略：實施 SAST（靜態應用程式安全測試）工具掃描，進行依賴項安全掃描（例如 Dependabot），並由具備安全意識的開發者進行人工審查，對所有處理使用者輸入的地方保持高度警惕。",**安全漏洞**：AI 生成的程式碼可能存在安全漏洞，如路徑遍歷。**安全意識**：資深工程師需警惕使用者輸入處理。**驗證策略**：透過 SAST、依賴掃描和人工審查進行驗證。
5.1-4,第 5 節：風險、原則與未來展望,5.1 「信任但驗證」原則：對抗程式碼幻覺與隱藏的缺陷,識別 AI 生成程式碼中過時或不恰當的 API/函式庫使用,"要求 AI 寫一段程式碼來解析 XML。AI 可能的產出：可能會建議使用 `xml.etree.ElementTree`，這沒有問題。但它也可能在某些情境下建議使用較舊或有安全疑慮的 `xml.dom.minidom`，或者為了一個極簡單的任務而引入一個龐大的第三方函式庫。\n驗證策略：對於 AI 建議引入的新依賴，查閱其官方文件，確認其維護狀態與適用場景。定期審查專案的依賴清單。",**過時 API/函式庫**：AI 可能建議使用過時或不恰當的 API/函式庫。**知識截止日期**：模型知識有截止日期，可能導致建議過時。**驗證策略**：查閱官方文件，確認依賴狀態。
5.2-1,第 5 節：風險、原則與未來展望,5.2 駕馭 AI 的侷限：理解並管理上下文視窗與知識截點,理解 AI 上下文視窗的侷限性,"上下文視窗，是指在單次對話或請求中，LLM 能夠同時「看到」和處理的資訊總量，通常以「權杖 (Token)」為單位計算。您輸入的每一個提示、貼上的每一個提示、AI 自己產生的每一個回應，都會佔用這個視窗的空間。當對話越來越長，最早的資訊就會被「擠出」視窗，AI 也會隨之「遺忘」這些資訊。",**上下文視窗**：AI 的短期工作記憶，限制單次處理資訊總量。**權杖計算**：輸入和輸出都佔用視窗空間。**資訊遺忘**：對話過長會導致早期資訊被遺忘。
5.3-1,第 5 節：風險、原則與未來展望,5.3 智慧財產權與安全：在 AI 時代的程式碼治理,理解 AI 生成程式碼的智慧財產權與安全議題,"使用 AI 生成的程式碼會帶來新的智財權與安全議題。本節將討論使用開源資料訓練的 LLM 可能產生的程式碼授權問題，以及如何避免在與公有雲 AI 的互動中洩漏公司敏感資訊或密鑰，並建立團隊內的使用規範。",**智財權議題**：AI 生成程式碼可能涉及授權問題。**安全風險**：避免敏感資訊洩漏。**使用規範**：建立團隊內部使用 AI 的規範。
5.4-1,第 5 節：風險、原則與未來展望,5.4 下一個前沿：從程式碼生成到代理式開發 (Agent-Based Development),理解代理式開發對軟體開發的影響,"Vibe Coding 正在演進。本節將展望未來，探討能夠自主規劃、執行、除錯的 AI 代理 (AI Agent) 將如何進一步改變軟體開發。我們將討論這對架構師和開發團隊的潛在影響，以及現在可以開始培養的相關技能。",**代理式開發**：AI 代理自主規劃、執行和除錯。**未來趨勢**：理解 AI 代理對開發模式的潛在影響。**技能培養**：培養適應未來開發模式的相關技能。
6.1-1,第 6 節：代理式開發實踐：從副駕到自主執行團隊,6.1 代理式開發的核心心態：從「指令者」到「委託者」,理解代理式開發的核心心態轉變,"本節旨在建立一個根本性的心態轉變。代理式開發的成功關鍵，不再是您能否寫出一個完美的、指導 AI 如何做的提示 (Prompt)，而是您能否定義出一個清晰的、可驗證的、關於「做什麼」(What) 與「完成標準」(Definition of Done) 的任務委託。我們將探討這種從「微觀管理」到「目標管理」的轉變，以及它如何要求開發者將重心從「編碼能力」轉移到「規格定義與系統思考能力」。",**心態轉變**：從指令者轉變為委託者。**目標管理**：定義清晰的任務和完成標準。**能力轉移**：重心從編碼轉向規格定義和系統思考。
6.2-1,第 6 節：代理式開發實踐：從副駕到自主執行團隊,6.2 設計「可代理」的任務：規格驅動的提示工程,撰寫能讓 AI 代理精確執行的任務規格書,"本節將深入探討如何撰寫一份能讓 AI 代理精確執行的「任務規格書」。這是一種更高層次的提示工程。我們將介紹一份高品質任務規格的四大組成要件：明確的最終目標 (Goal)、不可逾越的約束條件 (Constraints)、客觀的驗收標準 (Acceptance Criteria)，以及必要的上下文資源 (Contextual Resources)。本節將透過範例，展示如何將一個模糊的需求，轉化為一份 AI 代理可以理解並據以行動的、結構化的開發任務。",**任務規格書**：撰寫高品質的任務規格。**四大組成要件**：目標、約束、驗收標準、上下文資源。**結構化任務**：將模糊需求轉化為 AI 可理解的任務。
6.3-1,第 6 節：代理式開發實踐：從副駕到自主執行團隊,6.3 現代 AI 開發工具中的代理實踐,在 AI 開發工具中實踐代理式開發,"本節將聚焦於將代理式理念應用於您熟悉的工具中。我們將分析 GitHub Copilot 和 Gemini Code Assist 這類工具，如何透過指令鏈 (Command Chaining) 和更強的上下文理解能力，逐步展現出代理的雛形。我們將透過範例展示，如何下達一個更高層次的指令，例如：「請為 `auth-service` 增加 OIDC 支援，參考現有的單元測試風格補齊測試案例，並執行所有相關測試以確保沒有破壞性變更。」，並讓 AI 工具自主地完成一系列連貫的操作。",**代理實踐**：在現有 AI 工具中應用代理式理念。**指令鏈**：透過高層次指令讓 AI 自主完成連貫操作。**工具整合**：利用 GitHub Copilot 和 Gemini Code Assist 的代理能力。
6.4-1,第 6 節：代理式開發實踐：從副駕到自主執行團隊,6.4 建立與管理您的 AI 開發團隊：多代理協作,建立和管理多代理協作的 AI 開發團隊,"本節將探討代理式開發的終極形態——多個專職 AI 代理的協同作業。單一的通用代理能力有限，但一個由不同角色的代理組成的「虛擬團隊」將極具威力。我們將構想一個包含「規劃代理」、「編碼代理」、「測試代理」與「安全審計代理」的協作流程。作為架構師，您的新角色是設計這個 AI 團隊的結構、定義它們之間的「工作交接」協議，並監督整個自主開發流程的健康度，將架構師的職責提升到前所未有的「系統設計與流程設計」的高度。",**多代理協作**：多個專職 AI 代理協同作業。**虛擬團隊**：由不同角色代理組成的 AI 開發團隊。**架構師角色**：設計 AI 團隊結構、定義工作交接協議、監督開發流程.