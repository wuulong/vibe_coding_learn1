主類別,次類別,任務,範例提示 (Prompt),關鍵要素與原理
"第 1 節：奠定基礎 - AI 驅動的專案規劃與需求工程","1.1 AI 輔助的需求闡明：從原始輸入到結構化產物","從會議記錄中總結行動項目","你是一位資深的專案經理。請分析以下這份關於新功能開發的會議記錄文字稿。你的任務是：1. 總結會議的關鍵決策。2. 以表格形式列出所有分配的行動項目，包含負責人與截止日期。3. 識別出任何懸而未決的問題或需要進一步討論的主題。","**角色扮演** (`你是一位資深的專案經理`)：引導 AI 以特定領域的專業知識和視角進行分析。**結構化輸出** (`以表格形式列出`)：強制 AI 提供清晰、易於使用的結果。**目標導向** (`識別出...懸而未決的問題`)：指示 AI 專注於推動專案進展的具體資訊。"
"第 1 節：奠定基礎 - AI 驅動的專案規劃與需求工程","1.1 AI 輔助的需求闡明：從原始輸入到結構化產物","從原始筆記生成使用者故事與驗收標準","你是一位敏捷開發的業務分析師。請將以下來自使用者訪談的雜亂筆記，轉換為標準的使用者故事格式（As a [user], I want [action], so that [benefit]）。對於每一個使用者故事，請草擬 3-5 條具體的驗收標準 (Acceptance Criteria)，確保它們是可測試的。","**格式轉換** (`轉換為標準的使用者故事格式`)：利用 AI 對標準格式的理解，將非結構化資訊標準化。**具體化要求** (`草擬 3-5 條具體的驗收標準`)：指示 AI 深入思考需求的實現細節，而不僅是表面陳述。這有助於後續的開發與測試 [1]。"
"第 1 節：奠定基礎 - AI 驅動的專案規劃與需求工程","1.1 AI 輔助的需求闡明：從原始輸入到結構化產物","識別需求文件中的模糊與遺漏之處","請審閱以下這份軟體需求規格書 (SRS)。你的目標是找出潛在的問題。請特別標示出：1. 任何定義模糊或可能產生多種解釋的術語。2. 彼此之間存在衝突或矛盾的需求。3. 明顯遺漏的功能或非功能性需求（例如，未提及錯誤處理、安全性或效能）。","**批判性分析** (`找出潛在的問題`)：要求 AI 不僅是理解內容，更是要以批判性的眼光進行審查。**模式識別** (`明顯遺漏的功能`)：利用 AI 在大量軟體專案文件上訓練出的模式，識別出當前文件與「典型」完整文件之間的差距 [2]。"
"第 1 節：奠定基礎 - AI 驅動的專案規劃與需求工程","1.1 AI 輔助的需求闡明：從原始輸入到結構化產物","分析使用者回饋以發掘隱性需求","分析以下 100 條來自我們 APP 使用者的評論。請執行以下任務：1. 進行情感分析，將評論分為正面、負面和中性。2. 提取負面評論中提到的主要痛點。3. 根據使用者的抱怨和建議，推斷出他們可能需要但未直接說出的 3 個新功能或改進建議（隱性需求）。","**情感分析與主題提取** (`情感分析`、`主要痛點`)：這是 NLP 的經典應用，能快速從大量文本中提取洞見 [2]。**推理性分析** (`推斷出...隱性需求`)：這是更高級的應用，要求 AI 根據現有數據進行邏輯推理，找出潛在的商業機會或產品改進方向 [2]。"
"第 1 節：奠定基礎 - AI 驅動的專案規劃與需求工程","1.2 AI 應用於技術範疇界定與逆向工程","分析程式碼庫以生成技術摘要","你是一位資深軟體架構師。請分析這個 GitHub 儲存庫。你的任務是：1. 識別主要的程式語言、框架和關鍵依賴項。2. 描述此應用程式的高層架構（例如，是單體、微服務還是其他模式）。3. 總結其核心功能。4. 識別出任何潛在的技術債或過時的實踐。","**程式碼理解** (`分析這個 GitHub 儲存庫`)：利用 AI 對程式碼的深度理解能力，快速掌握一個陌生專案的技術堆疊與結構 [1]。**架構識別** (`描述...高層架構`)：AI 能夠識別程式碼組織方式中的模式，從而推斷出其架構風格。**品質評估** (`識別出...技術債`)：要求 AI 運用其知識庫，評估程式碼是否遵循現代最佳實踐。"
"第 1 節：奠定基礎 - AI 驅動的專案規劃與需求工程","1.2 AI 應用於技術範疇界定與逆向工程","為無文件的 API 生成文件","這裡有一個 Node.js/Express 應用程式的路由檔案（[貼上程式碼]）。這個 API 沒有任何文件。請為每個端點 (endpoint) 生成 OpenAPI 3.0 (Swagger) 格式的文件。文件應包含：1. 路徑和 HTTP 方法。2. 簡要的功能描述。3. 預期的請求參數（路徑、查詢、主體）。4. 可能的回應狀態碼和結構。","**程式碼到文件** (`生成 OpenAPI 3.0 格式的文件`)：這是一個極具價值的自動化任務，能將程式碼的實現細節直接轉換為標準化的 API 文件，節省大量手動編寫的時間 [1]。**結構推斷** (`預期的請求參數`、`回應結構`)：AI 透過分析程式碼邏輯，推斷出 API 的合約 (contract)，包括輸入和輸出。"
"第 1 節：奠定基礎 - AI 驅動的專案規劃與需求工程","1.2 AI 應用於技術範疇界定與逆向工程","從老舊程式碼生成現代化遷移計畫","我們有一個用 Java 8 和 Struts 框架編寫的單體式 Web 應用。我們計畫將其遷移到基於 Spring Boot 的微服務架構。請分析以下核心業務邏輯的程式碼片段 ([貼上程式碼])，並提出一個初步的遷移計畫，內容應包括：1. 建議的微服務邊界劃分。2. 每個微服務的潛在 API 端點。3. 遷移過程中可能遇到的挑戰。","**策略性建議** (`提出一個初步的遷移計畫`)：這要求 AI 不僅理解現狀，還要基於目標（微服務架構）提出具體的行動步驟。**領域劃分** (`建議的微服務邊界劃分`)：AI 根據程式碼的內聚性和耦合性，提出合理的服務拆分建議，這是微服務設計中的關鍵一步。**風險評估** (`可能遇到的挑戰`)：利用 AI 的廣泛知識，預見遷移過程中可能出現的技術和架構陷阱。"
"第 1 節：奠定基礎 - AI 驅動的專案規劃與需求工程","1.2 AI 應用於技術範疇界定與逆向工程","預測未來需求","基於我們過去兩年的 issue tracker 數據和功能發布記錄 ([提供摘要數據])，請分析使用者請求和開發趨勢。你的任務是：1. 識別出需求增長最快的產品領域。2. 預測在未來 12 個月內，最可能出現的三個主要功能需求或技術升級需求。3. 為每個預測提供理由。","**趨勢分析** (`分析...數據和...記錄`)：利用 AI 的數據分析能力，從歷史數據中找出模式和趨勢 [2]。**預測性洞察** (`預測在未來...需求`)：這將 AI 的角色從被動分析提升到主動預測，幫助團隊進行前瞻性的技術規劃和資源分配 [2]。"
"第 2 節：架構綜合 - 與 AI 夥伴共同設計系統","2.1 高層次系統設計與模式分析","比較架構模式以進行決策","你是一位經驗豐富的解決方案架構師。我們正在為一個新的電子商務平台規劃後端系統。請基於以下情境，為我們創建一個詳細的「單體 vs. 微服務」決策矩陣：- 團隊規模：8 位後端開發者。- 初始上市時間：目標 4 個月內推出 MVP。- 預期流量：初期中等，但預計支付和庫存模組在一年後會有高流量。- 技術棧偏好：團隊熟悉 Spring Boot。- 長期目標：希望未來能輕鬆整合第三方物流和行銷自動化服務。矩陣應評估的維度包括：開發速度、初始成本、可擴展性、維運複雜度、團隊自主性和技術演進的靈活性。","**情境驅動分析** (`基於以下情境`)：提供豐富的上下文，使 AI 的分析不僅是通用的，而是針對特定專案的 [3]。**創建決策工具** (`創建一個...決策矩陣`)：要求 AI 生成一個結構化的分析工具，而不僅僅是文字描述，這有助於團隊進行客觀比較。**多維度評估** (`評估的維度包括...`)：指定評估的標準，確保分析的全面性，涵蓋從開發到維運的各個方面 [4, 5]。"
"第 2 節：架構綜合 - 與 AI 夥伴共同設計系統","2.1 高層次系統設計與模式分析","選擇合適的 SDLC 模型","我們即將啟動一個專案，開發一款創新的 AI 驅動的數據分析工具。專案需求在初期尚不明確，且技術風險較高。請比較瀑布式、敏捷式（Scrum）和螺旋式模型，並推薦最適合此專案的 SDLC 模型。你的推薦應基於對需求不確定性、風險管理和客戶回饋循環的考量，並解釋原因。","**模型對比與推薦** (`比較...並推薦`)：要求 AI 進行比較分析並給出結論性的建議，模擬了顧問的角色。**風險導向** (`基於...風險管理`)：指示 AI 將風險作為評估的核心因素，這對於高不確定性的專案至關重要，並與螺旋模型的設計初衷相符 [6, 7]。"
"第 2 節：架構綜合 - 與 AI 夥伴共同設計系統","2.1 高層次系統設計與模式分析","生成技術選型分析報告","為一個新的即時通訊應用程式後端，請生成一份關於訊息佇列 (Message Queue) 技術選型的分析報告。請比較 RabbitMQ、Apache Kafka 和 AWS SQS。報告應涵蓋以下方面：1. 架構模型（例如，點對點 vs. 發布/訂閱）。2. 效能與吞吐量。3. 持久性與可靠性保證。4. 易用性與社群支援。5. 適用場景分析。","**技術深度比較** (`比較 RabbitMQ、Apache Kafka 和 AWS SQS`)：利用 AI 龐大的技術知識庫，對特定技術領域的工具進行深入比較。**結構化報告** (`報告應涵蓋以下方面`)：提供清晰的報告結構，確保 AI 的輸出是有組織、全面且易於理解的。"
"第 2 節：架構綜合 - 與 AI 夥伴共同設計系統","2.2 詳細元件與資料模型設計","生成關聯式資料庫綱要 (SQL)","你是一位資料庫管理員 (DBA)。請為一個部落格應用程式設計一個 PostgreSQL 資料庫綱要。需求如下：- 一個 `users` 資料表，包含 id, username, email, password_hash, created_at。- 一個 `posts` 資料表，包含 id, title, content, user_id (外鍵關聯到 users.id), created_at, updated_at。- 一個 `comments` 資料表，包含 id, content, user_id, post_id, created_at。- 一個 `tags` 資料表和一個 `post_tags` 中介資料表，以實現多對多關聯。請生成包含 `CREATE TABLE` 語句、主鍵、外鍵約束和適當索引的完整 SQL 腳本。","**明確的實體與關聯** (`users`, `posts`, `comments` 等)：清晰地定義資料模型中的核心實體及其屬性 [8]。**指定關聯類型** (`外鍵關聯`, `多對多關聯`)：明確告知 AI 實體之間的關係，以便生成正確的約束和中介資料表。**要求完整性** (`生成完整 SQL 腳本`)：確保輸出是可直接執行的，包含所有必要的 DDL (Data Definition Language) 語句 [9]。"
"第 2 節：架構綜合 - 與 AI 夥伴共同設計系統","2.2 詳細元件與資料模型設計","設計 NoSQL 文件模型 (MongoDB)","我們正在為一個產品目錄設計一個 MongoDB 資料庫。請為 `product` 集合設計一個文件結構。一個產品應包含：- 基本資訊（名稱、描述、價格）。- 一個嵌入的 `reviews` 陣列，每個 review 包含評分、評論內容和使用者 ID。- 一個 `categories` 字串陣列。- `inventory` 資訊（庫存量、倉庫位置）。請以 JSON 格式提供一個範例文件，並解釋為何在此場景下，嵌入 `reviews` 比使用引用更合適。","**針對 NoSQL 的設計** (`設計一個 MongoDB 文件結構`)：提示 AI 考慮 NoSQL 的特性，如文件嵌入和非正規化。**解釋設計決策** (`解釋為何...更合適`)：要求 AI 不僅提供結果，還要解釋其背後的設計原理。這有助於驗證 AI 的「思考」過程，並作為學習工具。"
"第 2 節：架構綜合 - 與 AI 夥伴共同設計系統","2.2 詳細元件與資料模型設計","生成 API 規格 (OpenAPI)","請為一個使用者管理微服務生成 OpenAPI 3.0 規格的 YAML 文件。該服務需要提供以下端點：1. `POST /users`：創建新使用者。2. `GET /users/{id}`：根據 ID 獲取使用者資訊。3. `PUT /users/{id}`：更新使用者資訊。4. `DELETE /users/{id}`：刪除使用者。請為每個端點定義請求主體 (request body)、路徑參數 (path parameters) 和回應模型 (response models)，並包含成功和錯誤的回應範例。","**基於功能的端點定義** (`提供以下端點`)：從應用程式的功能反向推導出 API 的具體介面。**完整的合約定義** (`定義請求主體...回應模型`)：確保生成的規格是完整的，涵蓋了 API 互動的所有方面，這對於前後端分離開發至關重要。"
"第 2 節：架構綜合 - 與 AI 夥伴共同設計系統","2.3 AI 驅動的架構視覺化","序列圖 (Sequence Diagram)","請使用 Mermaid.js 語法生成一個使用者登入流程的序列圖。流程如下：1. 使用者 (User) 在客戶端 (Client) 輸入使用者名稱和密碼。2. 客戶端向認證服務 (Auth Service) 發送一個 POST 請求。3. 認證服務驗證資料庫 (Database) 中的憑證。4. 資料庫回傳驗證結果。5. 如果成功，認證服務生成一個 JWT Token 並返回給客戶端。6. 客戶端儲存 Token 並將使用者重定向到儀表板 (Dashboard)。","**循序描述** (`流程如下...`)：序列圖的核心是時間和順序，因此按步驟清晰地描述互動流程至關重要。**明確的參與者** (`User`, `Client`, `Auth Service`, `Database`, `Dashboard`)：定義圖中的所有角色或元件，AI 會將它們轉換為圖中的垂直生命線。"
"第 2 節：架構綜合 - 與 AI 夥伴共同設計系統","2.3 AI 驅動的架構視覺化","C4 模型容器圖 (C4 Container Diagram)","請使用 Mermaid.js 的 C4 語法，為一個電子商務系統生成一個容器圖 (Container Diagram)。系統邊界為「網路商店」。容器包括：1. 一個名為「Web App」的 React 單頁應用。2. 一個名為「API Gateway」的後端服務。3. 一個名為「產品服務 (Product Service)」的微服務，使用 Java/Spring Boot。4. 一個名為「訂單服務 (Order Service)」的微服務，使用 Go。5. 一個名為「產品資料庫 (Product DB)」的 PostgreSQL 資料庫。6. 一個名為「訂單資料庫 (Order DB)」的 MongoDB。請描述它們之間的互動關係。","**遵循特定模型語法** (`使用 Mermaid.js 的 C4 語法`)：明確指示 AI 使用特定圖表模型的語法，以獲得標準化的輸出。**定義邊界與容器** (`系統邊界為...`, `容器包括...`)：提供 C4 模型所需的核心元素：系統邊界和其中的容器（可執行的單元）。**描述關係** (`描述它們之間的互動關係`)：定義容器之間的依賴和通訊方式，這是圖表的核心內容。"
"第 2 節：架構綜合 - 與 AI 夥伴共同設計系統","2.3 AI 驅動的架構視覺化","雲端架構圖 (Cloud Architecture Diagram)","請生成一個描述部署在 AWS 上的高可用性 Web 應用的 Mermaid.js 圖表。架構應包含：- 一個 Route 53 DNS。- 一個 Application Load Balancer (ALB)。- 一個 Auto Scaling Group，其中包含多個 EC2 實例。- 這些 EC2 實例運行在不同的可用區 (Availability Zones)。- 一個 RDS PostgreSQL 資料庫，具有主備副本 (Primary/Standby)。請使用 `graph TD` 語法，並將相關元件分組在 VPC 和可用區的子圖中。","**使用圖形語法** (`使用 graph TD`)：指定 Mermaid 的圖形方向（從上到下）。**分組與層次結構** (`分組在 VPC 和可用區的子圖中`)：要求 AI 使用子圖 (subgraph) 來表示網路邊界和容錯域，使圖表更具結構性和可讀性。這對於繪製複雜的雲端架構至關重要。"
"第 3 節：加速實作 - AI 驅動的編碼與重構","3.1 程式碼生成與演算法實作","生成遵循設計模式的程式碼","你是一位遵循 SOLID 原則的資深 Java 開發者。請使用工廠模式 (Factory Pattern) 來實現一個 `NotificationService`。這個工廠應該能夠根據輸入的類型（""EMAIL"", ""SMS"", ""PUSH""）創建對應的通知器實例 (`EmailNotifier`, `SmsNotifier`, `PushNotifier`)。所有通知器都應實現一個共同的 `Notifier` 介面，該介面有一個 `send(message)` 方法。請提供所有相關的介面和類別的完整程式碼。","**角色與原則** (`遵循 SOLID 原則的資深 Java 開發者`)：設定 AI 的角色和行為準則，引導其生成高品質、易於維護的程式碼。**指定設計模式** (`使用工廠模式`)：明確要求 AI 應用特定的軟體設計模式，這對於構建可擴展和模組化的系統至關重要。**提供完整上下文** (`提供所有相關的介面和類別`)：確保 AI 的輸出是完整且可運行的，而不僅僅是零碎的片段。"
"第 3 節：加速實作 - AI 驅動的編碼與重構","3.1 程式碼生成與演算法實作","實作複雜的業務邏輯","請用 Python 實作一個處理購物車結帳的函式 `checkout(cart, user_id)`。邏輯應包含：1. 檢查 `cart` 中每項商品的庫存。2. 如果庫存不足，拋出一個自訂的 `OutOfStockError` 異常。3. 計算總金額，如果使用者是 VIP 會員，則給予 10% 的折扣。4. 呼叫一個虛構的 `PaymentGateway.charge(amount, card_details)` 服務。5. 如果支付失敗，需要處理支付閘道的異常並拋出 `PaymentFailedError`。6. 成功後，更新資料庫中的庫存。請包含完整的錯誤處理和日誌記錄。","**詳細的業務規則** (`邏輯應包含...`)：將複雜的業務需求分解為清晰、循序的步驟，引導 AI 準確實現。**強調錯誤處理** (`拋出一個自訂的...異常`, `處理...異常`)：這是生產級程式碼的關鍵。明確要求 AI 處理各種失敗情境，能生成更健壯的程式碼。**指定非功能性需求** (`日誌記錄`)：除了核心邏輯，還需指定如日誌、監控等非功能性需求。"
"第 3 節：加速實作 - AI 驅動的編碼與重構","3.1 程式碼生成與演算法實作","將老舊程式碼翻譯並現代化","這裡有一段使用傳統 `XMLHttpRequest` 的 JavaScript 程式碼，用於發起一個 AJAX 請求。請將其重構為使用現代的 `async/await` 語法和 `fetch` API。重構後的程式碼應該包含 `try...catch` 區塊來處理網路錯誤和非 200 的 HTTP 狀態碼。請在程式碼中加入註解，解釋新舊寫法的主要區別。","**明確的轉換目標** (`重構為使用現代的 async/await 語法和 fetch API`)：清晰地定義轉換的起點和終點。**要求最佳實踐** (`包含 try...catch 區塊`)：確保轉換後的程式碼遵循現代的非同步程式設計最佳實踐。**教育性輸出** (`加入註解，解釋...區別`)：讓 AI 的輸出不僅是一個解決方案，也是一個學習工具，幫助開發者理解技術的演進。"
"第 3 節：加速實作 - AI 驅動的編碼與重構","3.1 程式碼生成與演算法實作","根據自然語言描述生成特定功能的公用程式函式","請用 Python 編寫一個名為 `is_valid_email(email_string)` 的公用程式函式，它接受一個字串作為輸入，如果字串是有效的電子郵件地址格式則返回 `True`，否則返回 `False`。請考慮常見的郵件格式規則。","**需求到程式碼** (`根據自然語言描述`)：直接將功能需求轉化為可執行的程式碼。**通用性** (`公用程式函式`)：專注於生成可重用的、獨立的小型功能單元。"
"第 3 節：加速實作 - AI 驅動的編碼與重構","3.1 程式碼生成與演算法實作","生成特定資料結構的操作程式碼 (例如，樹的遍歷、圖的搜尋)","假設我有一個二元樹節點類別 `TreeNode` (包含 `value`, `left_child`, `right_child` 屬性)，請為其實作一個深度優先搜尋 (DFS) 的前序遍歷函式 `preorder_traversal(root_node)`，並返回一個包含節點值的列表。","**演算法實作** (`深度優先搜尋`)：AI 應用其演算法知識生成標準實現。**資料結構操作** (`二元樹節點類別`)：針對特定資料結構的常見操作進行程式碼生成。"
"第 3 節：加速實作 - AI 驅動的編碼與重構","3.2 AI 除錯與重構循環","解釋並除錯複雜程式碼","你是一位 Python 專家。這裡有一個函式，它理應計算斐波那契數列，但它的效能很差，而且在 n=0 時會出錯。請：1. 逐行解釋這段遞迴程式碼的邏輯。2. 指出其效能瓶頸（時間複雜度）和錯誤的原因。3. 提供一個使用動態規劃（備忘錄法）優化過的、修正了錯誤的版本。","**診斷與解釋** (`解釋...邏輯`, `指出...瓶頸和錯誤`)：要求 AI 不僅修復程式碼，還要解釋問題的根源，這有助於開發者學習並避免未來犯同樣的錯誤 [10]。**提供優化方案** (`提供一個使用動態規劃...的版本`)：指示 AI 應用特定的演算法知識來重構程式碼，以達到效能優化的目標。"
"第 3 節：加速實作 - AI 驅動的編碼與重構","3.2 AI 除錯與重構循環","進行安全性程式碼審查","你是一位應用程式安全專家。請審查以下這段處理檔案上傳的 PHP 程式碼。你的任務是識別所有潛在的安全漏洞，例如：- 檔案類型未驗證導致的任意檔案上傳。- 未對使用者輸入進行過濾處理導致的路徑遍歷 (Path Traversal) 攻擊。- 任何其他可能的安全風險。請為每個發現的漏洞提供詳細的解釋和一個安全的、修正後的程式碼範例。","**安全專家角色** (`你是一位應用程式安全專家`)：引導 AI 從安全性的角度進行審查，利用其在大量安全漏洞案例上訓練出的知識。**針對性漏洞檢查** (`例如：...`)：提供具體的漏洞類型作為提示，可以幫助 AI 更專注地尋找特定類型的常見錯誤 [10]。**提供修復方案** (`提供...修正後的程式碼範例`)：確保輸出是可操作的，不僅僅是問題報告。"
"第 3 節：加速實作 - AI 驅動的編碼與重構","3.2 AI 除錯與重構循環","重構以提高可讀性和可維護性","這段 C# 程式碼雖然功能正常，但可讀性很差：它使用了模糊的變數名，函式過長，並且缺乏註解。請將其重構，遵循 C# 的標準編碼規範。重構應包括：1. 使用有意義的變數名和函式名。2. 將長函式分解為多個較小的、單一職責的輔助函式。3. 添加適當的 XML 文件註解。","**關注程式碼品質** (`提高可讀性和可維護性`)：這類提示專注於軟體工程的「軟」技能，而不僅僅是功能正確性。**具體的重構指令** (`使用有意義的變數名`, `分解...函式`)：給出清晰的重構目標，引導 AI 進行結構性和風格上的改進。"
"第 3 節：加速實作 - AI 驅動的編碼與重構","3.2 AI 除錯與重構循環","根據錯誤訊息和堆疊追蹤提出修復建議","我的 Python 程式拋出了以下 `TypeError`: `can only concatenate str (not \"int\") to str`。相關的程式碼片段是 `message = \"User ID: \" + user_id`，其中 `user_id` 是一個整數。請解釋錯誤原因並提供修正後的程式碼。","**錯誤分析** (`根據錯誤訊息和堆疊追蹤`)：AI 解讀執行時錯誤，定位問題。**精準修復** (`提供修正後的程式碼`)：提供直接可用的修復方案。"
"第 3 節：加速實作 - AI 驅動的編碼與重構","3.2 AI 除錯與重構循環","識別程式碼中的「壞味道」(code smells) 並建議重構方向","請檢視以下這段 Java 程式碼，識別其中可能存在的程式碼壞味道，例如過長的函式、重複的程式碼塊、過於複雜的條件判斷等，並為每個壞味道提出重構建議。\n```java\n// [貼上程式碼片段]\n```","**品質評估** (`識別程式碼中的「壞味道」`)：AI 運用其對良好程式碼實踐的理解來發現潛在問題。**重構指導** (`建議重構方向`)：提供改進程式碼結構和品質的具體建議。"
"第 3 節：加速實作 - AI 驅動的編碼與重構","3.3 自動化容器化","為 Node.js 應用生成優化的 Dockerfile","請為一個 Node.js/Express 應用程式生成一個生產環境可用的 `Dockerfile`。該檔案應遵循以下最佳實踐：1. 使用多階段建構：一個階段用於安裝依賴項和建構，另一個階段用於運行應用程式，以減小最終映像檔大小。2. 使用一個非 root 使用者來運行應用程式。3. 正確處理 `node_modules` 的快取。4. 使用 `CMD` 而非 `ENTRYPOINT` 來啟動伺服器。","**最佳實踐導向** (`遵循以下最佳實踐`)：明確列出業界公認的最佳實踐，引導 AI 生成高品質、安全且高效的 `Dockerfile` [11, 12]。**多階段建構** (`使用多階段建構`)：這是 Docker 優化的關鍵技術，要求 AI 應用此技術能顯著改善映像檔大小。**安全性考量** (`使用一個非 root 使用者`)：將安全性要求直接納入提示中。"
"第 3 節：加速實作 - AI 驅動的編碼與重構","3.3 自動化容器化","為多服務應用生成 Docker Compose 檔案","請為一個包含三個服務的 Web 應用生成一個 `docker-compose.yml` 檔案：- 一個名為 `frontend` 的 React 應用，其 `Dockerfile` 位於 `./frontend` 目錄，並應將容器的 3000 連接埠映射到主機的 3000 連接埠。- 一個名為 `backend` 的 Python/Flask API，其 `Dockerfile` 位於 `./backend` 目錄，並依賴於 `db` 服務。- 一個名為 `db` 的 PostgreSQL 服務，使用官方的 `postgres:13` 映像檔，並需要一個名為 `pgdata` 的具名資料卷來持久化儲存資料。","**服務定義與依賴** (`包含三個服務`, `依賴於 db 服務`)：清晰地描述應用程式的組成部分及其關係，這是 `docker-compose` 的核心 [13]。**具體的設定** (`連接埠映射`, `資料卷`)：提供詳細的設定參數，使 AI 能生成準確且可直接使用的設定檔 [14]。"
"第 3 節：加速實作 - AI 驅動的編碼與重構","3.3 自動化容器化","整合建構參數與環境變數","擴充先前的 `docker-compose.yml` 檔案。`backend` 服務需要從一個 `.env` 檔案中讀取環境變數，該檔案包含 `DATABASE_URL` 和 `API_KEY`。此外，`frontend` 服務的 `Dockerfile` 需要一個名為 `REACT_APP_API_URL` 的建構參數 (build argument)，其值應設定為 `http://backend:5000`。請更新 `docker-compose.yml` 檔案以包含這些設定。","**進階設定** (`環境變數`, `建構參數`)：展示如何使用 AI 處理更複雜的容器化場景，這些場景在實際開發中非常普遍。**配置外部化** (`從一個.env 檔案中讀取`)：要求 AI 遵循將配置與程式碼分離的最佳實踐。"
"第 3 節：加速實作 - AI 驅動的編碼與重構","3.3 自動化容器化","為特定框架 (例如 Django, Ruby on Rails) 生成標準的 Dockerfile","請為一個使用 Gunicorn 運行的標準 Django 專案生成一個生產環境可用的 `Dockerfile`。應包含依賴項安裝、靜態檔案收集以及正確的啟動命令。","**框架特定知識** (`標準 Django 專案`)：AI 應用其對特定 Web 框架部署方式的了解。**生產最佳實踐** (`生產環境可用`)：引導 AI 生成符合生產部署要求的設定。"
"第 3 節：加速實作 - AI 驅動的編碼與重構","3.3 自動化容器化","根據 Dockerfile 解釋其每個指令的用途和最佳實踐","請逐行解釋以下 `Dockerfile` 中每個指令（如 `FROM`, `WORKDIR`, `COPY`, `RUN`, `CMD`）的用途，並說明是否有可以改進的最佳實踐。\n```dockerfile\n# [貼上 Dockerfile 內容]\n```","**文件解釋與教學** (`解釋其每個指令的用途`)：AI 作為教學工具，幫助理解 Dockerfile 的構成。**最佳實踐審查** (`是否有可以改進的最佳實踐`)：AI 進行審查並提出改進建議。"
"第 3 節：加速實作 - AI 驅動的編碼與重構","3.4 AI 輔助的行為驅動開發 (BDD)","從使用者故事生成 Gherkin feature 檔案","你是一位 BDD 專家。請基於以下使用者故事，為一個使用者註冊功能撰寫一個 Gherkin feature 檔案：『身為一位新訪客，我想要能夠註冊一個帳戶，以便我可以使用網站的會員功能。』請包含至少一個成功場景和一個帳號已存在導致失敗的場景。Feature 應包含背景 (Background) 設定通用步驟，例如『Given 我在註冊頁面』。","**角色扮演** (`你是一位 BDD 專家`)：引導 AI 以 BDD 的思維模式和標準語法進行撰寫。**需求轉化** (`基於以下使用者故事...`)：將自然語言的需求轉化為結構化的 Gherkin 語法。**場景多樣性** (`包含至少一個成功場景和一個...失敗的場景`)：確保 AI 考慮到不同的執行路徑，提升測試覆蓋的初步構想。**Gherkin 結構** (`Feature 應包含背景 (Background)`)：指示 AI 使用 Gherkin 的標準結構元素，如 `Feature`, `Background`, `Scenario`, `Given`, `When`, `Then`。"
"第 3 節：加速實作 - AI 驅動的編碼與重構","3.4 AI 輔助的行為驅動開發 (BDD)","從 Gherkin 生成步驟定義 (step definition) 骨架","你是一位熟悉 [Python Behave / Java Cucumber / JavaScript Cucumber.js] 的測試自動化工程師。請根據以下 Gherkin 場景，為其生成對應的步驟定義 (step definition) 骨架程式碼。請為每個步驟生成一個函式/方法，並在其中包含一個提示註解，說明該步驟需要實現的邏輯。Gherkin 場景：\n```gherkin\nScenario: 成功的使用者登入\n  Given 我是一個已註冊的使用者，帳號為 \"testuser\" 密碼為 \"password123\"\n  When 我在登入頁面輸入我的帳號和密碼\n  And 我點擊登入按鈕\n  Then 我應該被重新導向到我的儀表板頁面\n  And 我應該看到歡迎訊息 \"歡迎回來, testuser!\"\n```","**特定框架** (`熟悉 [Python Behave / Java Cucumber / JavaScript Cucumber.js]`)：指定目標測試框架，讓 AI 生成符合該框架語法和裝飾器 (decorator/annotation) 的程式碼。**程式碼骨架** (`生成對應的步驟定義骨架程式碼`)：AI 負責生成樣板程式碼，開發者只需填充具體的實現邏輯。**註解引導** (`包含一個提示註解`)：AI 在骨架中加入註解，提示開發者每個步驟需要完成的自動化操作，加速開發過程。"
"第 3 節：加速實作 - AI 驅動的編碼與重構","3.4 AI 輔助的行為驅動開發 (BDD)","為特定的 BDD 步驟生成程式碼片段","我正在使用 Selenium WebDriver with Java 和 Cucumber 為網站撰寫 BDD 測試。請為以下 Gherkin 步驟生成 Java 程式碼片段：`When 我在搜尋框中輸入 \"AI in software engineering\"`。假設 `WebDriver driver` 實例已經初始化，並且搜尋框的 HTML ID 是 `search-input`。","**具體步驟實現** (`為以下 Gherkin 步驟生成 Java 程式碼片段`)：針對單一的 BDD 步驟，要求 AI 生成實際的自動化互動程式碼。**上下文提供** (`假設 WebDriver driver 實例已經初始化`, `搜尋框的 HTML ID 是 search-input`)：提供必要的上下文資訊（如使用的工具、變數名、元素定位器），使 AI 生成的程式碼更準確、更易於整合。**工具特定 API** (`Selenium WebDriver with Java`)：AI 需要了解特定測試工具的 API 用法才能生成有效的程式碼。"
"第 3 節：加速實作 - AI 驅動的編碼與重構","3.4 AI 輔助的行為驅動開發 (BDD)","根據 Gherkin feature 檔案生成測試資料建議","分析以下 Gherkin feature 檔案，特別是 `Examples` 表格。請為每個場景輪廓 (Scenario Outline) 建議更全面的測試資料組合，以覆蓋更多邊界情況和等價類。\n```gherkin\n# [貼上 Gherkin feature 內容]\n```","**測試資料擴展** (`建議更全面的測試資料組合`)：AI 輔助思考更完整的測試覆蓋，特別是針對參數化的測試。**場景分析** (`分析以下 Gherkin feature 檔案`)：AI 需要理解 Gherkin 的語義來提出有效的資料建議。"
"第 3 節：加速實作 - AI 驅動的編碼與重構","3.4 AI 輔助的行為驅動開發 (BDD)","將非 BDD 格式的測試案例轉換為 Gherkin 語法","我有一些傳統格式的測試案例描述，例如：『測試使用者登入：1. 輸入有效帳號。2. 輸入有效密碼。3. 點擊登入。4. 驗證是否跳轉到儀表板。』請將其轉換為 Gherkin 的 Given/When/Then 格式的場景。","**格式轉換** (`轉換為 Gherkin 語法`)：AI 輔助將現有測試資產遷移到 BDD 框架。**語義理解** (`傳統格式的測試案例描述`)：AI 需要理解原始測試案例的意圖。"
"第 3 節：加速實作 - AI 驅動的編碼與重構","3.5 AI 輔助的 SOLID 原則重構","重構類別以符合單一職責原則 (SRP)","你是一位遵循 SOLID 原則的資深軟體架構師。以下這個 `UserService` Java 類別同時處理使用者資料管理和寄送通知郵件，違反了單一職責原則。請將其重構為兩個獨立的類別：一個 `UserPersistenceService` 負責使用者資料的 CRUD 操作，另一個 `NotificationService` 負責寄送郵件。請提供重構後的兩個類別的完整程式碼，並解釋你的重構如何符合 SRP。\n```java\n// [貼上原始的 UserService 程式碼]\npublic class UserService {\n    public void registerUser(String username, String email) { /* ... 儲存使用者 ... */ /* ... 寄送歡迎郵件 ... */ }\n    public User getUser(String id) { /* ... 獲取使用者 ... */ return null; }\n    // ... 其他方法 ...\n}\n```","**原則聚焦** (`違反了單一職責原則`, `如何符合 SRP`)：明確指出要應用的 SOLID 原則，並要求 AI 解釋其重構決策。**職責分離** (`重構為兩個獨立的類別`)：指導 AI 將混合的職責拆分到不同的模組中，這是 SRP 的核心思想。**提供原始碼上下文** (`// [貼上原始的 UserService 程式碼]`)：讓 AI 基於現有程式碼進行重構，而不是從零開始。"
"第 3 節：加速實作 - AI 驅動的編碼與重構","3.5 AI 輔助的 SOLID 原則重構","使用開閉原則 (OCP) 擴展類別功能","你是一位熟悉設計模式的 Python 開發者。我們有一個 `ShapeCalculator` 類別，它目前只能計算矩形面積。我們需要增加計算圓形面積的功能，但根據開閉原則，我們不應修改 `ShapeCalculator` 的現有程式碼。請展示如何使用策略模式 (Strategy Pattern) 或類似方法來擴展功能，使得可以輕易加入新的形狀計算，而無需修改 `ShapeCalculator` 本身。請提供所有相關的類別和介面定義。\n```python\n# 原始 ShapeCalculator\nclass Shape:\n    pass\n\nclass Rectangle(Shape):\n    def __init__(self, width, height):\n        self.width = width\n        self.height = height\n\nclass ShapeCalculator:\n    def calculate_area(self, shape):\n        if isinstance(shape, Rectangle):\n            return shape.width * shape.height\n        # BAD: Adding Circle here would modify this class\n        return 0\n```","**OCP 強調** (`不應修改...現有程式碼`)：直接點明開閉原則的核心要求——對擴展開放，對修改封閉。**設計模式應用** (`使用策略模式或類似方法`)：提示 AI 運用已知的設計模式來達成 OCP，策略模式是實現此原則的經典方法之一。**可擴展性** (`使得可以輕易加入新的形狀計算`)：要求 AI 設計的解決方案具有良好的擴展性，以應對未來的需求變更。"
"第 3 節：加速實作 - AI 驅動的編碼與重構","3.5 AI 輔助的 SOLID 原則重構","檢查子類別是否符合里氏替換原則 (LSP)","你是一位關注程式碼正確性的軟體工程師。我們有一個 `Bird` 基底類別和一個 `Penguin` 子類別。`Bird` 有一個 `fly()` 方法。企鵝是一種鳥，但不會飛。請分析以下 Python 程式碼，判斷 `Penguin` 類別的設計是否違反了里氏替換原則 (LSP)。如果違反了，請解釋原因，並提出修改建議，使得 `Penguin` 仍然可以被視為 `Bird` 的一種，但不違反 LSP (例如，透過重新思考 `fly()` 方法的語義或繼承結構)。\n```python\nclass Bird:\n    def fly(self):\n        print(\"This bird can fly\")\n\nclass Penguin(Bird):\n    def fly(self):\n        raise Exception(\"Penguins cannot fly!\") # 或者 pass, 或者 return False\n\n# 使用範例\ndef make_bird_fly(bird: Bird):\n    bird.fly()\n\nmake_bird_fly(Penguin()) # 可能會產生非預期行為或錯誤\n```","**LSP 驗證** (`判斷...是否違反了里氏替換原則`)：要求 AI 對繼承關係的正確性進行評估，核心是子類別是否能無縫替換父類別。**行為一致性** (`企鵝是一種鳥，但不會飛`)：點出子類別與父類別在行為上的不一致，這是 LSP 常見的違反點。**提供修復方案** (`提出修改建議`)：不僅要求 AI 識別問題，還要提供解決方案，引導開發者設計更穩健的繼承體系。"
"第 3 節：加速實作 - AI 驅動的編碼與重構","3.5 AI 輔助的 SOLID 原則重構","根據介面隔離原則 (ISP) 重構大型介面","你是一位 API 設計專家。以下這個 `Worker` Java 介面過於龐大，它包含了所有類型工人可能執行的動作，但並非所有實作類別都需要所有方法。例如，一個 `RobotWorker` 可能不需要 `eat()` 或 `sleep()` 方法。請根據介面隔離原則 (ISP) 將此介面重構為多個更小、更具體的介面 (例如 `Workable`, `Feedable`, `Restable`)，並展示一個 `HumanWorker` 和一個 `RobotWorker` 類別如何實現這些新介面。\n```java\n// 原始的胖介面\ninterface Worker {\n    void work();\n    void eat();\n    void sleep();\n    void recharge(); // 假設這是 Robot 特有的\n}\n\nclass HumanWorker implements Worker { /* ... */ }\nclass RobotWorker implements Worker { /* ... 但 eat/sleep 不適用 */ }\n```","**ISP 應用** (`根據介面隔離原則...重構`)：明確指示 AI 應用 ISP，避免用戶端被迫依賴它們不需要的介面。**介面拆分** (`重構為多個更小、更具體的介面`)：指導 AI 進行介面分解，使得每個介面都服務於一個特定的客戶端需求。**角色化介面** (`Workable`, `Feedable`, `Restable`)：鼓勵 AI 創建基於角色的介面，使類別可以根據其能力選擇實現哪些介面。"
"第 3 節：加速實作 - AI 驅動的編碼與重構","3.5 AI 輔助的 SOLID 原則重構","依賴反轉原則 (DIP) 重構程式碼以依賴抽象","你是一位推崇依賴反轉原則的 Python 開發者。在以下程式碼中，`ReportGenerator` 高層模組直接依賴於 `ConsoleLogger` 低層模組。這違反了依賴反轉原則。請重構此程式碼：1. 建立一個抽象的 `Logger` 介面 (或抽象基礎類別)。2. 讓 `ConsoleLogger` 實現此介面。3. 修改 `ReportGenerator` 使其依賴於 `Logger` 抽象，而不是 `ConsoleLogger` 實體。請提供重構後的完整程式碼，並解釋如何透過依賴注入 (Dependency Injection) 來提供具體的 logger 實例給 `ReportGenerator`。\n```python\n# 原始程式碼\nclass ConsoleLogger:\n    def log(self, message):\n        print(f\"LOG: {message}\")\n\nclass ReportGenerator:\n    def __init__(self):\n        self.logger = ConsoleLogger() # 直接依賴具體實現\n\n    def generate_report(self, data):\n        self.logger.log(\"Generating report...\")\n        # ... report generation logic ...\n        self.logger.log(\"Report generated.\")\n```","**DIP 目標** (`依賴於抽象，而不是實體`)：清晰地闡述依賴反轉原則的核心思想。**抽象建立** (`建立一個抽象的 Logger 介面`)：指導 AI 引入抽象層，這是實現 DIP 的關鍵步驟。**依賴注入** (`解釋如何透過依賴注入`)：要求 AI 不僅修改依賴關係，還要展示如何將具體的依賴項（如 `ConsoleLogger`）在執行時傳遞給高層模組，這是 DIP 的常見實踐方式。"
"第 3 節：加速實作 - AI 驅動的編碼與重構","3.5 AI 輔助的 SOLID 原則重構","解釋某段程式碼如何違反了特定的 SOLID 原則，並提供修正範例","請分析以下 C# 程式碼片段。它是否違反了開閉原則 (OCP)？如果是，請解釋是如何違反的，並提供一個使用例如策略模式或裝飾器模式的重構版本以符合 OCP。\n```csharp\n// [貼上程式碼片段]\n```","**原則性分析** (`解釋某段程式碼如何違反了特定的 SOLID 原則`)：AI 進行深度程式碼分析，並以 SOLID 原則為基準進行評估。**教學性解釋** (`解釋是如何違反的`)：幫助開發者理解原則的實際應用和常見誤區。"
"第 3 節：加速實作 - AI 驅動的編碼與重構","3.5 AI 輔助的 SOLID 原則重構","針對一段程式碼，依次評估其是否符合 SOLID 的每一項原則，並給出總體評價和改進建議","請全面審查以下這段 Python 類別的程式碼。針對 SOLID 的五個原則（SRP, OCP, LSP, ISP, DIP），逐一評估該類別的設計是否符合，並解釋原因。最後，給出一個總體評價和主要的改進建議方向。\n```python\n# [貼上類別程式碼]\n```","**全面評估** (`依次評估其是否符合 SOLID 的每一項原則`)：進行系統性的設計品質審查。**綜合建議** (`總體評價和主要的改進建議方向`)：提供宏觀的改進思路。"
"第 3 節：加速實作 - AI 驅動的編碼與重構","3.6 AI 輔助的 API 互動與整合","根據 OpenAPI/Swagger 規格生成 API 用戶端程式碼","你是一位熟悉 [Python/Java/JavaScript] 的 API 整合專家。這裡有一份 OpenAPI 3.0 規格檔案 (`[貼上規格內容或提供檔案路徑]`)，請為其中的 `/users` 和 `/products` 端點生成對應的用戶端請求程式碼。程式碼應包含處理請求、回應以及基本錯誤處理的函式。","**規格驅動程式碼生成** (`根據 OpenAPI 3.0 規格檔案`)：利用標準化的 API 描述直接生成可用的用戶端程式碼，減少手動編寫的重複工作。**多語言支援** (`熟悉 [Python/Java/JavaScript]`)：AI 能夠根據指定的程式語言生成對應的用戶端。**錯誤處理基礎** (`基本錯誤處理`)：提示 AI 考慮到 API 呼叫中常見的失敗情境。"
"第 3 節：加速實作 - AI 驅動的編碼與重構","3.6 AI 輔助的 API 互動與整合","生成呼叫第三方 API 的程式碼片段 (例如，Stripe 付款、Twilio SMS)","請用 Node.js 為我生成一段程式碼，用於呼叫 Stripe API 來創建一個新的支付意圖 (Payment Intent)。需要包含必要的 API 金鑰處理（從環境變數讀取）、金額、貨幣和一個簡單的成功/失敗日誌記錄。","**特定服務整合** (`呼叫 Stripe API`)：針對常見的第三方服務，AI 可以提供快速的整合程式碼範例。**安全實踐** (`API 金鑰處理（從環境變數讀取）`)：引導 AI 生成安全的程式碼，避免硬編碼敏感資訊。**實用性** (`簡單的成功/失敗日誌記錄`)：加入基本的日誌記錄，方便調試和追蹤。"
"第 3 節：加速實作 - AI 驅動的編碼與重構","3.6 AI 輔助的 API 互動與整合","為 API 端點生成模擬 (Mock) 回應資料","根據以下 OpenAPI 規格中對 `GET /api/v1/items/{itemId}` 端點的回應結構描述，請生成 3 個不同的模擬 JSON 回應範例，包含一個成功回應和兩個不同錯誤情況的回應（例如，找不到項目、無效請求）。\n```yaml\n# [貼上相關的 OpenAPI 回應結構片段]\n```","**測試輔助** (`生成模擬 (Mock) 回應資料`)：方便前端或用戶端在後端 API 未完成時進行開發和測試。**規格遵循** (`根據以下 OpenAPI 規格`)：確保模擬資料符合 API 合約。"
"第 3 節：加速實作 - AI 驅動的編碼與重構","3.6 AI 輔助的 API 互動與整合","解釋如何處理 API 的速率限制 (Rate Limiting) 和重試邏輯","我正在整合一個外部 API，該 API 有速率限制（例如每分鐘 100 次請求）。請解釋在 Python 中實現客戶端速率控制和帶有指數退避 (exponential backoff) 的自動重試邏輯的最佳實踐和常用庫。","**API 使用策略** (`處理 API 的速率限制和重試邏輯`)：提供處理真實世界 API 互動複雜性的指導。**最佳實踐與工具推薦** (`最佳實踐和常用庫`)：AI 分享經驗和工具，幫助開發者構建更健壯的 API 用戶端。"
"第 3 節：加速實作 - AI 驅動的編碼與重構","3.7 AI 輔助的程式碼註解與文件化","為現有函式或類別生成說明性註解 (Docstrings/JSDoc)","你是一位注重程式碼可讀性的開發者。請為以下這個 Python 函式 `calculate_complex_metric(data, config)` 生成符合 PEP 257 標準的 Docstring。Docstring 應描述函式的功能、參數（型別和說明）以及返回值。\n```python\n# [貼上函式程式碼]\ndef calculate_complex_metric(data, config):\n    # ... 複雜的邏輯 ...\n    return result\n```","**自動化文件** (`生成符合 PEP 257 標準的 Docstring`)：AI 能夠理解程式碼邏輯並自動生成標準格式的註解，提高程式碼的可維護性。**上下文理解** (`描述函式的功能、參數...以及返回值`)：AI 需要分析程式碼來提取這些關鍵資訊。"
"第 3 節：加速實作 - AI 驅動的編碼與重構","3.7 AI 輔助的程式碼註解與文件化","將程式碼邏輯翻譯成自然語言解釋","請用簡明扼要的自然語言解釋以下這段 Java 程式碼片段的功能和主要步驟：\n```java\n// [貼上程式碼片段]\n```","**程式碼可解釋性** (`翻譯成自然語言解釋`)：幫助開發者快速理解陌生的或複雜的程式碼片段，降低學習曲線。"
"第 3 節：加速實作 - AI 驅動的編碼與重構","3.7 AI 輔助的程式碼註解與文件化","根據程式碼變更自動更新相關註解","我修改了以下 Python 函式，改變了其參數和部分邏輯。舊的 Docstring 如下。請根據新的程式碼生成更新後的 Docstring。\n舊 Docstring:\n```\n# [貼上舊 Docstring]\n```\n新函式程式碼:\n```python\n# [貼上修改後的函式程式碼]\n```","**文件同步** (`根據程式碼變更自動更新相關註解`)：幫助保持程式碼和文件的一致性，減少文件過時的問題。**差異分析** (隱含)：AI 需要比較新舊程式碼以確定註解的變更點。"
"第 3 節：加速實作 - AI 驅動的編碼與重構","3.7 AI 輔助的程式碼註解與文件化","從程式碼註解生成 Markdown 格式的簡易 API 文件","分析以下這個 Java 類別及其 Javadoc 註解。請提取公開方法 (public methods) 的資訊（方法名、參數、返回值、簡要描述），並生成一個 Markdown 格式的簡易 API 文件摘要。\n```java\n// [貼上帶有 Javadoc 的類別程式碼]\n```","**文件生成** (`生成 Markdown 格式的簡易 API 文件`)：自動化產生面向開發者的 API參考文件。**註解解析** (`分析以下這個 Java 類別及其 Javadoc 註解`)：AI 從結構化的註解中提取資訊。"
"第 3 節：加速實作 - AI 驅動的編碼與重構","3.8 AI 輔助的演算法選擇與優化建議","針對特定問題推薦合適的資料結構或演算法","我需要處理一個頻繁進行插入、刪除和搜尋操作的資料集合，資料量大約在 10 萬筆左右，搜尋效能至關重要。請推薦幾種合適的 Python 資料結構或演算法，並比較它們在這種情境下的優缺點。","**問題導向推薦** (`針對特定問題推薦`)：AI 基於問題的特性（如操作類型、資料規模、效能要求）提供專業建議。**權衡分析** (`比較它們...的優缺點`)：AI 不僅給出答案，還能分析不同方案的利弊，輔助決策。"
"第 3 節：加速實作 - AI 驅動的編碼與重構","3.8 AI 輔助的演算法選擇與優化建議","分析現有程式碼的效能瓶頸並提出優化建議","你是一位 Python 效能優化專家。請分析以下這段處理資料的程式碼，指出潛在的效能瓶頸，並提出至少三個具體的優化建議（例如，改進迴圈、使用更高效的庫函式、並行化等）。\n```python\n# [貼上待分析的程式碼]\n```","**效能診斷** (`指出潛在的效能瓶頸`)：AI 運用其對語言特性和常見低效寫法的理解來識別問題。**具體優化方案** (`提出至少三個具體的優化建議`)：提供可操作的改進措施，幫助提升程式碼執行效率。"
"第 3 節：加速實作 - AI 驅動的編碼與重構","3.8 AI 輔助的演算法選擇與優化建議","比較不同演算法在特定情境下的時間與空間複雜度","對於一個未排序的整數陣列，請比較使用『氣泡排序』、『快速排序』和 Python 內建的 `sort()` 方法來排序的時間複雜度（平均情況和最壞情況）和空間複雜度。並簡要說明它們的適用場景。","**理論分析** (`比較...時間與空間複雜度`)：AI 運用其電腦科學基礎知識進行理論比較。**情境化比較** (`適用情境`)：幫助開發者根據實際需求做出選擇。"
"第 3 節：加速實作 - AI 驅動的編碼與重構","3.8 AI 輔助的演算法選擇與優化建議","將遞迴演算法轉換為迭代版本，或反之","以下是一個計算階乘的遞迴 Python 函式。請將其轉換為一個等效的迭代版本。\n```python\ndef factorial_recursive(n):\n    if n == 0:\n        return 1\n    else:\n        return n * factorial_recursive(n-1)\n```","**演算法轉換** (`將遞迴演算法轉換為迭代版本`)：展示 AI 在不同演算法實現範式間的轉換能力，有助於理解或效能優化。"
"第 4 節：智慧品質保證 - AI 在自動化測試中的應用","4.1 智慧測試案例與資料生成","為函式生成單元測試","你是一位注重測試覆蓋率的軟體開發工程師。請為以下這個 Python 函式 `calculate_discount(price, is_premium_member)`，使用 `pytest` 框架生成一組單元測試。測試案例應涵蓋：1. 標準情況（非會員，正價）。2. 會員折扣情況。3. 邊界情況（價格為 0 或負數）。4. 型別錯誤（例如，價格為字串）。請確保測試函式命名清晰，並包含斷言 (assertions)。","**指定測試框架** (`使用 pytest 框架`)：確保生成的程式碼符合特定工具的語法和慣例。**要求測試覆蓋類型** (`涵蓋：...`)：明確指示 AI 考慮各種測試場景，包括正面、負面和邊界測試，以確保測試的全面性 [15]。**遵循命名慣例** (`命名清晰`)：這有助於生成易於理解和維護的測試程式碼。"
"第 4 節：智慧品質保證 - AI 在自動化測試中的應用","4.1 智慧測試案例與資料生成","從使用者故事生成驗收測試","基於以下使用者故事和驗收標準，請使用 Gherkin 語法 (Given/When/Then) 為一個 Web 應用生成一個功能測試場景。使用者故事：「作為一個已登入的使用者，我想要將商品加入購物車，以便我之後可以購買。」驗收標準：- 當我點擊「加入購物車」按鈕時，商品應被加入。- 購物車圖示上的數字應加一。- 頁面應顯示一個成功的提示訊息。","**行為驅動開發 (BDD)** (`使用 Gherkin 語法`)：要求 AI 生成一種能被業務人員和開發者共同理解的測試描述語言，促進團隊協作。**從需求到測試** (`基於以下使用者故事...`)：這展示了如何將高層次的需求直接轉化為可執行的測試規格，實現了需求與測試的緊密連結 [16]。"
"第 4 節：智慧品質保證 - AI 在自動化測試中的應用","4.1 智慧測試案例與資料生成","生成逼真的測試資料","請為一個註冊表單生成 10 組 JSON 格式的假資料 (mock data)。每組資料應包含 `firstName`, `lastName`, `email` (格式需正確), `password` (長度至少 8 位，包含大小寫字母和數字) 和 `birthDate` (格式為 YYYY-MM-DD，且年齡在 18 到 99 歲之間)。","**資料生成與約束** (`生成 10 組...`, `格式需正確`, `長度至少 8 位...`)：利用 AI 生成符合特定規則和约束的結構化資料，這對於需要大量且多樣化輸入的測試場景非常有用 [15]。"
"第 4 節：智慧品質保證 - AI 在自動化測試中的應用","4.2 自我修復自動化與根本原因分析","分析 E2E 測試失敗日誌","你是一位資深的 QA 自動化工程師。我們的 Cypress 端對端測試在 CI/CD 流程中失敗了。以下是失敗測試的日誌和錯誤訊息：[貼上 Cypress 日誌和錯誤截圖的文字描述]。請分析這些資訊，並提出 3 個最可能的失敗根本原因。對於每個原因，請說明你的推斷依據，並建議下一步的除錯步驟。","**專家角色扮演** (`你是一位資深的 QA 自動化工程師`)：引導 AI 以特定領域的專業知識來分析問題。**提供完整上下文** (`[貼上...日誌和錯誤訊息]`)：提供盡可能多的失敗相關資訊，能讓 AI 的分析更準確。**結構化診斷** (`提出 3 個最可能的...原因`, `建議...除錯步驟`)：要求 AI 提供一個結構化的、可操作的診斷報告，而不僅僅是模糊的猜測。"
"第 4 節：智慧品質保證 - AI 在自動化測試中的應用","4.2 自我修復自動化與根本原因分析","從堆疊追蹤推斷根本原因","我們的 Java 應用程式在生產環境中拋出了一個 `NullPointerException`。以下是相關的堆疊追蹤：[貼上堆疊追蹤]。請分析此堆疊追蹤，並解釋：1. 異常發生的確切位置（類別和行號）。2. 根據呼叫堆疊，哪個物件最可能是 `null`？3. 為了永久修復此問題，應該在哪段程式碼中加入空值檢查？","**程式碼級別分析** (`分析此堆疊追蹤`)：這是一個非常具體的技術任務，利用 AI 對程式語言和執行時錯誤的理解來進行診斷。**根本原因推斷** (`哪個物件最可能是 null？`)：要求 AI 進行邏輯推理，而不僅僅是讀取堆疊追蹤的表面資訊。"
"第 5 節：DevOps 前沿 - AI 在 CI/CD 與基礎設施管理中的應用","5.1 AI 輔助的生產級基礎設施即程式碼 (IaC)","生成具備安全性的 AWS VPC Terraform 程式碼","**第一步 (生成):** `請使用 Terraform 為 AWS 生成一個生產環境的 VPC。VPC 應包含：- 兩個公共子網路和兩個私有子網路，分佈在不同的可用區。- 一個 Internet Gateway 和一個 NAT Gateway。- 配置路由表，確保私有子網路的實例可以透過 NAT Gateway 訪問網際網路。` **第二步 (護欄驗證):** `現在，扮演一位雲端安全專家。審查剛剛生成的 Terraform 程式碼。請檢查並修正以下問題：1. 網路 ACL (NACL) 規則是否過於寬鬆？請應用最小權限原則。2. 是否啟用了 VPC Flow Logs，並將其導向 S3 儲存桶進行稽核？如果沒有，請加入。3. 確保所有相關資源（如 S3 儲存桶）都應用了加密和適當的標籤 (tags)。`","**情境豐富的規格** (`生產環境的 VPC`, `公共/私有子網路`)：提供詳細的、符合真實世界需求的規格，而不僅僅是通用請求 [17]。**護欄驅動生成** (`扮演一位...安全專家`, `審查...並修正`)：採用兩步法，先生成再驗證，強制 AI 進行自我審查和修正，以彌補其在單次生成中容易忽略安全細節的弱點 [18, 19]。**非功能性需求** (`VPC Flow Logs`, `標籤`)：明確提出監控、稽核和管理方面的需求，這些是生產級基礎設施的關鍵組成部分。"
"第 5 節：DevOps 前沿 - AI 在 CI/CD 與基礎設施管理中的應用","5.1 AI 輔助的生產級基礎設施即程式碼 (IaC)","為 Kubernetes 應用生成 Helm Chart","請為一個由 `frontend` 和 `backend` 兩個微服務組成的應用程式，生成一個基本的 Helm Chart 結構。`frontend` 是一個 Nginx 服務，`backend` 是一個基於 Go 的 API 服務。請創建 `Chart.yaml`, `values.yaml`，以及 `templates` 目錄下的 `deployment.yaml` 和 `service.yaml` 檔案。在 `values.yaml` 中，應允許配置每個服務的副本數 (replicaCount) 和映像檔標籤 (image.tag)。","**特定工具語法** (`生成一個基本的 Helm Chart 結構`)：指示 AI 生成特定 IaC 工具（此處為 Helm）所需的檔案結構和語法。**參數化配置** (`在 values.yaml 中，應允許配置...`)：要求 AI 遵循 Helm 的最佳實踐，將可變配置提取到 `values.yaml` 中，以提高 Chart 的可重用性和靈活性。"
"第 5 節：DevOps 前沿 - AI 在 CI/CD 與基礎設施管理中的應用","5.1 AI 輔助的生產級基礎設施即程式碼 (IaC)","生成 Ansible Playbook 用於伺服器配置","請生成一個 Ansible Playbook，用於在一台新的 Ubuntu 22.04 伺服器上安裝和配置 Nginx。Playbook 應完成以下任務：1. 使用 `apt` 模組更新套件快取並安裝 `nginx`。2. 使用 `template` 模組，將一個本地的 `nginx.conf.j2` 範本檔案部署到伺服器的 `/etc/nginx/nginx.conf`。3. 使用 `service` 模組，確保 `nginx` 服務已啟動並設定為開機自啟。","**任務自動化** (`生成一個 Ansible Playbook`)：利用 AI 自動化伺服器配置管理任務，減少手動操作和錯誤。**冪等性** (`確保...已啟動`)：Ansible 的核心原則是冪等性。提示中使用的動詞（如 `安裝`、`確保`）隱含了對冪等性的要求，AI 通常能很好地理解並生成對應的模組用法。"
"第 5 節：DevOps 前沿 - AI 在 CI/CD 與基礎設施管理中的應用","5.2 CI/CD 流程自動化","GitHub Actions","請為一個 Python 專案生成一個 GitHub Actions workflow 的 YAML 檔案。流程應在每次推送到 `main` 分支時觸發。它需要包含以下作業 (jobs)：1. `test` 作業：設置 Python 3.9 環境，安裝依賴項 (`requirements.txt`)，並使用 `pytest` 運行測試。2. `lint` 作業：使用 `flake8` 檢查程式碼風格。3. `build-and-push` 作業：此作業應在 `test` 和 `lint` 成功後運行。它會建構一個 Docker 映像檔，並將其推送到 GitHub Container Registry (GHCR)。請使用矩陣策略 (matrix strategy) 在 Python 3.8, 3.9 和 3.10 上並行運行 `test` 作業。","**觸發條件與依賴** (`在每次推送到 main 分支時觸發`, `在 test 和 lint 成功後運行`)：清晰地定義流程的觸發時機和作業之間的依賴關係 [20]。**矩陣建構** (`使用矩陣策略`)：要求 AI 使用 CI/CD 工具的進階功能，以並行方式在多個環境中進行測試，提高效率。**整合容器化** (`建構一個 Docker 映像檔`)：將程式碼建構與容器化流程無縫整合，這是現代 CI/CD 的常見實踐。"
"第 5 節：DevOps 前沿 - AI 在 CI/CD 與基礎設施管理中的應用","5.2 CI/CD 流程自動化","GitLab CI/CD","請為一個 Node.js 專案生成一個 `.gitlab-ci.yml` 檔案。流程應包含以下階段 (stages)：`build`, `test`, `deploy`。- `build` 階段：安裝 npm 依賴項並執行建構腳本。- `test` 階段：運行 `jest` 測試。- `deploy` 階段：此階段應只在對 `main` 分支的提交上運行。它會將建構好的靜態檔案部署到 AWS S3。請使用 GitLab 的快取 (caching) 功能來快取 `node_modules` 目錄，以加速後續的流程運行。","**階段定義** (`包含以下階段...`)：GitLab CI 的核心是階段。明確定義階段有助於 AI 生成結構清晰的流程。**環境特定部署** (`只在對 main 分支的提交上運行`)：展示如何使用 CI/CD 工具的規則 (rules) 或條件 (only/except) 來控制特定作業的執行時機。**效能優化** (`使用 GitLab 的快取功能`)：要求 AI 應用平台提供的效能優化特性，以減少不必要的重複工作 [21]。"
"第 5 節：DevOps 前沿 - AI 在 CI/CD 與基礎設施管理中的應用","5.2 CI/CD 流程自動化","Jenkins","請為一個 Java/Maven 專案生成一個宣告式 (Declarative) Jenkinsfile。流程應定義 `build`, `test`, 和 `package` 三個階段。- `agent` 應指定一個包含 JDK 11 和 Maven 的 Docker 容器。- `build` 階段：執行 `mvn compile`。- `test` 階段：執行 `mvn test` 並使用 `junit` 步驟來歸檔測試結果。- `package` 階段：執行 `mvn package` 並使用 `archiveArtifacts` 步驟來儲存生成的 `.jar` 檔案。","**宣告式語法** (`生成一個宣告式 Jenkinsfile`)：指定 Jenkinsfile 的現代語法，它比腳本式 (Scripted) 語法更結構化、更易於維護。**環境定義** (`agent 應指定一個...Docker 容器`)：展示如何在 CI/CD 流程中定義一個乾淨、可重複的建構環境。**產物管理** (`歸檔測試結果`, `儲存生成的.jar 檔案`)：要求 AI 整合 CI/CD 工具的產物管理功能，這對於追蹤建構結果和後續部署至關重要。"
"第 6 節：主動式維運 - AI 在生產監控與維護中的角色","6.1 對話式日誌分析與監控","趨勢分析與異常偵測","分析過去 24 小時內我們 `api-gateway` 服務的日誌。請回答以下問題：1. HTTP 5xx 錯誤率的整體趨勢是什麼？是否有任何異常的峰值？2. 哪個 API 端點的平均回應時間最長？3. 與前一天相比，今天的總請求量有何變化？","**自然語言查詢** (`分析...日誌`, `回答以下問題`)：將複雜的數據查詢需求用簡單的自然語言表達，AI 負責將其轉化為實際的數據分析操作 [22]。**多維度分析** (`錯誤率`, `回應時間`, `請求量`)：一次性提出多個維度的問題，讓 AI 進行全面的健康狀況評估。"
"第 6 節：主動式維運 - AI 在生產監控與維護中的角色","6.1 對話式日誌分析與監控","根本原因假設","在今天上午 10:05，我們的 `payment-service` 服務的錯誤率突然飆升。以下是該時間點前後 5 分鐘的日誌片段：[貼上日誌]。請分析這些日誌，並結合一個常見的微服務架構，提出三個最可能的根本原因。例如，是資料庫連接問題、下游服務 `fraud-detection-service` 超時，還是自身部署了有問題的新版本？","**情境與數據結合** (`在...時間點`, `以下是...日誌`)：提供具體的時間點和原始數據，為 AI 的分析提供堅實的基礎。**引導性假設** (`例如，是...`)：給出一些可能的方向，可以幫助 AI 更好地聚焦其分析範圍，並利用其知識庫對這些假設進行評估 [22, 23]。"
"第 6 節：主動式維運 - AI 在生產監控與維護中的角色","6.1 對話式日誌分析與監控","從日誌中提取使用者行為模式","請分析以下使用者活動日誌，這些日誌記錄了使用者在我們電子商務網站上的點擊流。請識別出使用者在購買流程中最常見的放棄點（即他們在哪個步驟之後離開的比例最高）。","**行為分析** (`識別出...最常見的放棄點`)：這是一個更偏向業務分析的應用，利用 AI 從原始日誌中提取出有價值的商業洞察，幫助優化產品和使用者體驗。"
"第 6 節：主動式維運 - AI 在生產監控與維護中的角色","6.2 AI 輔助的事件回應與 Kubernetes 故障排除","Kubernetes Pod 崩潰","你是一位資深的網站可靠性工程師 (SRE)。我的一個 Kubernetes Pod 處於 `CrashLoopBackOff` 狀態。以下是 `kubectl describe pod <pod-name>` 的輸出：[貼上 describe 輸出]。以下是 `kubectl logs <pod-name> --previous` 的輸出：[貼上崩潰前的日誌]。請基於這些資訊，提供：1. 導致 Pod 崩潰的 3 個最可能的原因（例如，OOMKilled、設定檔錯誤、應用程式啟動失敗）。2. 對於每個原因，需要執行哪些 `kubectl` 命令來進一步驗證。3. 一個可能的修復方案。","**專家角色與情境** (`你是一位資深的 SRE`, `Pod 處於 CrashLoopBackOff 狀態`)：為 AI 設定清晰的角色和問題背景，使其能夠調用特定領域的專業知識 [24]。**結合多種數據源** (`describe 輸出`, `logs 輸出`)：提供來自不同命令的數據，讓 AI 能夠進行交叉引用和關聯分析，得出更準確的結論。**提供可操作的指令** (`需要執行哪些 kubectl 命令`)：要求 AI 的輸出是具體、可執行的，直接指導工程師的下一步行動。"
"第 6 節：主動式維運 - AI 在生產監控與維護中的角色","6.2 AI 輔助的事件回應與 Kubernetes 故障排除","應用程式效能下降","我們的 Web 應用的平均回應時間在過去一小時內從 100ms 增加到了 800ms。監控儀表板顯示資料庫 CPU 使用率正常，但 `user-service` 的延遲顯著增加。請提出一個系統性的故障排除計畫，涵蓋從應用程式層、網路層到基礎設施層的檢查點。","**系統性思維** (`提出一個系統性的故障排除計畫`)：要求 AI 提供一個結構化的、全面的調查框架，而不是零散的建議。這有助於確保不會遺漏任何可能的故障點。**排除法** (`資料庫 CPU 使用率正常`)：提供已知的正常資訊，可以幫助 AI 縮小問題範圍，更專注於可能的瓶頸。"
"第 6 節：主動式維運 - AI 在生產監控與維護中的角色","6.2 AI 輔助的事件回應與 Kubernetes 故障排除","安全事件初步調查","我們的入侵偵測系統 (IDS) 報告稱，在伺服器 `prod-web-01` 上檢測到可疑的對外網路連線。以下是相關的防火牆日誌：[貼上日誌]。請扮演一位資安分析師，分析這些日誌，並回答：1. 這些連線的目標 IP 和連接埠是什麼？2. 這種流量模式是否符合已知的惡意軟體行為（如 C&C 通訊）？3. 建議立即採取的圍堵措施是什麼（例如，隔離主機、封鎖 IP）？","**安全分析師角色** (`扮演一位資安分析師`)：引導 AI 從網路安全和威脅情報的角度分析數據。**威脅識別** (`是否符合已知的惡意軟體行為`)：利用 AI 在大量安全事件和威脅情報上訓練出的知識，對當前事件進行模式匹配和定性。**事件回應建議** (`建議立即採取的圍堵措施`)：要求 AI 提供符合標準事件回應流程的、具體的行動建議。"
